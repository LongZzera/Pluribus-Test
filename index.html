<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLURIBUS: A JUN√á√ÉO | The Bunker Experience</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        
        /* --- UI GERAL --- */
        #overlay, #narrative-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #ffcc00; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000;
            cursor: pointer; text-align: center;
        }
        #narrative-overlay { display: none; cursor: default; background: rgba(0,0,0,0.95); z-index: 2000; }
        
        #overlay h1 { text-shadow: 0 0 10px #ffcc00; margin-bottom: 10px; }
        #overlay p { opacity: 0.8; max-width: 600px; line-height: 1.5; }

        /* Estilo Telltale */
        .narrative-title { font-size: 32px; margin-bottom: 20px; color: #fff; text-transform: uppercase; letter-spacing: 4px; border-bottom: 2px solid #ffcc00; padding-bottom: 10px; }
        .narrative-body { font-size: 18px; max-width: 700px; color: #ddd; margin-bottom: 40px; line-height: 1.6; }
        .narrative-choices { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .choice-btn {
            background: transparent; border: 2px solid #555; color: #aaa;
            padding: 15px 30px; font-family: 'Courier New'; font-size: 16px;
            cursor: pointer; transition: 0.3s; min-width: 200px;
        }
        .choice-btn:hover { border-color: #ffcc00; color: #ffcc00; background: rgba(255, 204, 0, 0.1); }
        .consequence-text { margin-top: 20px; font-style: italic; color: #ff3333; opacity: 0; transition: opacity 1s; }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 50;
            mix-blend-mode: difference;
        }

        /* --- NOTIFICA√á√ÉO DE TROF√âU --- */
        #trophy-popup {
            position: absolute; top: -100px; left: 50px; 
            width: 300px; height: 60px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 40px;
            border-left: 5px solid #ffcc00;
            display: flex; align-items: center; padding: 10px 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            transition: top 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 2000; pointer-events: none;
        }
        #trophy-icon {
            width: 40px; height: 40px; border-radius: 50%;
            background: #ffcc00; color: #000;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 20px; margin-right: 15px;
        }
        #trophy-text h4 { margin: 0; color: #fff; font-size: 14px; font-family: sans-serif; }
        #trophy-text p { margin: 0; color: #aaa; font-size: 12px; font-family: sans-serif; }

        /* --- HUD DE STATUS --- */
        #hud-overlay {
            position: absolute; top: 20px; right: 20px; width: 250px;
            padding: 15px; background: rgba(20, 20, 0, 0.1);
            border: 2px solid #ffcc00; color: #ffcc00;
            font-family: 'Courier New', monospace; font-size: 14px;
            z-index: 95; pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.2);
        }
        .hud-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .hud-label { font-weight: bold; }
        .hud-bar-container { width: 100px; height: 10px; background: #111; border: 1px solid #554400; margin-top: 4px; }
        .hud-bar-fill { height: 100%; background: #ffcc00; transition: width 0.3s; }
        .danger { color: #ff3333; }
        .danger .hud-bar-fill { background: #ff3333; }
        #timer-display { font-size: 20px; font-weight: bold; text-align: center; margin-bottom: 10px; color: #fff; text-shadow: 0 0 5px #ffcc00; }
        .hud-quota-val { color: #fff; font-weight: bold; }

        /* --- EFEITOS VHS/CRT --- */
        #vhs-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 90;
            background: linear-gradient(rgba(18, 16, 0, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 200, 0, 0.06), rgba(255, 200, 0, 0.02), rgba(255, 200, 0, 0.06));
            background-size: 100% 2px, 3px 100%;
            box-shadow: inset 0 0 150px rgba(0,0,0,0.9);
        }
        #scanline {
            width: 100%; height: 10px; background: rgba(255,200,0,0.05); opacity: 0.1;
            position: absolute; z-index: 91; pointer-events: none;
            animation: scanline 6s linear infinite;
        }
        @keyframes scanline { 0% { top: -10%; } 100% { top: 110%; } }
        
        #message-log {
            position: absolute; bottom: 20px; left: 20px; color: #ffcc00;
            font-size: 14px; opacity: 0.8; pointer-events: none; z-index: 80;
            text-shadow: 1px 1px 2px black;
        }

        #peephole-ui {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 200;
            background: radial-gradient(circle, transparent 10%, black 70%); 
            pointer-events: auto;
        }

        #visitor-visual {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: monospace; font-size: 14px; color: #ffcc00; white-space: pre;
            text-align: center; opacity: 0.8; filter: blur(1px);
            pointer-events: none;
        }

        #dialogue-box {
            position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%);
            width: 600px; background: rgba(20, 15, 0, 0.9); border: 2px solid #ffcc00;
            padding: 15px; color: #ffcc00; font-family: 'Courier New'; display: none;
            text-align: center;
        }
        
        .typing-effect::after { content: '‚ñå'; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #door-controls {
            position: absolute; bottom: 50px; width: 100%; display: flex; 
            justify-content: center; gap: 20px; pointer-events: auto;
        }

        .door-btn {
            background: #111; border: 2px solid #555; color: #aaa; padding: 15px 30px;
            font-family: 'Courier New'; font-weight: bold; cursor: pointer;
            transition: 0.2s; text-transform: uppercase; letter-spacing: 2px;
        }
        .door-btn:hover { color: #fff; border-color: #fff; }
        .btn-interrogate { border-color: #ffcc00; color: #ffcc00; }
        .btn-interrogate:hover { background: #332200; }
        .btn-open { border-color: #aaaa00; color: #ffff00; }
        .btn-open:hover { background: #333300; }
        .btn-shock { border-color: #ff3333; color: #ff3333; }
        .btn-shock:hover { background: #330000; }

    </style>
</head>
<body>

<div id="overlay">
    <h1>PLURIBUS: A JUN√á√ÉO</h1>
    <p>MODO HIST√ìRIA: SOBREVIV√äNCIA DE 8 DIAS</p>
    <br>
    <p style="font-size: 12px; color: #aa8800;">[CLIQUE PARA INICIAR]</p>
    <br>
    <p>
        <b>OBJETIVO:</b> Sobreviva at√© o Dia 8.<br>
        <b>COTA:</b> Deixe entrar pelo menos 2 pessoas por dia.<br>
        <b>ALERTA:</b> A porta enfraquece se voc√™ demorar para atender.
    </p>
</div>

<!-- NARRATIVE OVERLAY (TELLTALE STYLE) -->
<div id="narrative-overlay">
    <div class="narrative-title" id="narrative-title">NOITE 1: O SINAL</div>
    <div class="narrative-body" id="narrative-body">
        O sistema de r√°dio captou uma transmiss√£o antiga da Iniciativa Pluribus. 
        Parece ser um c√≥digo de ativa√ß√£o para as unidades rob√≥ticas da cidade.
        Sua fam√≠lia acha que isso pode nos salvar, mas ativar o sinal pode revelar nossa posi√ß√£o.
    </div>
    <div class="narrative-choices" id="narrative-choices">
        <!-- Buttons injected via JS -->
    </div>
    <div class="consequence-text" id="consequence-text">Sua fam√≠lia vai se lembrar disso.</div>
</div>

<div id="game-container">
    <div id="vhs-overlay"></div>
    <div id="scanline"></div>
    <div id="crosshair"></div>
    
    <div id="trophy-popup">
        <div id="trophy-icon">üèÜ</div>
        <div id="trophy-text">
            <h4>Conquista Desbloqueada</h4>
            <p id="trophy-name">Nome do Trof√©u</p>
        </div>
    </div>

    <div id="hud-overlay">
        <div id="timer-display">05:00</div>
        <div class="hud-row">
            <span class="hud-label">DIA:</span>
            <span id="hud-day">1/8</span>
        </div>
        <!-- NOVA LINHA DE COTA -->
        <div class="hud-row">
            <span class="hud-label">COTA DI√ÅRIA:</span>
            <span id="hud-quota" class="hud-quota-val">0/2</span>
        </div>
        <div class="hud-row" id="row-sanity">
            <span class="hud-label">SANIDADE:</span>
            <div class="hud-bar-container"><div id="bar-sanity" class="hud-bar-fill" style="width: 80%"></div></div>
        </div>
        <div class="hud-row" id="row-door">
            <span class="hud-label">PORTA:</span>
            <div class="hud-bar-container"><div id="bar-door" class="hud-bar-fill" style="width: 100%"></div></div>
        </div>
        <div class="hud-row" id="row-family">
            <span class="hud-label">FAM√çLIA:</span>
            <div class="hud-bar-container"><div id="bar-family" class="hud-bar-fill" style="width: 100%"></div></div>
        </div>
        <div class="hud-row">
             <span class="hud-label" style="font-size:10px; color:#aa8800; margin-top:5px;">RECURSOS (ENERGIA): <span id="hud-energy">80</span>%</span>
        </div>
    </div>

    <div id="message-log"></div>

    <div id="peephole-ui">
        <div id="visitor-visual"></div>
        <div id="dialogue-box"><span id="dialogue-text">...</span></div>
        <div id="door-controls">
            <button class="door-btn btn-interrogate" onclick="window.gameActions.interrogate()">QUEM √â?</button>
            <button class="door-btn btn-open" onclick="window.gameActions.openDoor()">ABRIR</button>
            <button class="door-btn btn-shock" onclick="window.gameActions.shockDoor()">ELETROCUTAR</button>
            <button class="door-btn" onclick="window.gameActions.exitPeephole()">VOLTAR</button>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

    const apiKey = ""; 
    
    // --- VARI√ÅVEIS DE C√ÇMERA (NOVO) ---
    let camPitch = 0;
    let camYaw = 0;
    let targetPitch = 0;
    let targetYaw = 0;
    const LOOK_SPEED = 0.002;
    const SMOOTH_FACTOR = 0.15; 
    const MAX_YAW = Math.PI / 1.5; 
    const MAX_PITCH = Math.PI / 3; 

    const NARRATIVE_EVENTS = [
        {
            title: "NOITE 1: O PROTOCOLO DE HERAN√áA",
            body: "Voc√™ encontra um arquivo criptografado no sistema chamado 'Protocolo de Heran√ßa'. Ele detalha que a fam√≠lia no bunker foi selecionada geneticamente para 'repopular' a Terra, mas o custo foi a elimina√ß√£o dos 'imperfeitos' l√° fora. Sua fam√≠lia pergunta o que voc√™ est√° lendo.",
            choices: [
                { text: "Contar a verdade (Aumenta Sanidade, Diminui Humor)", effect: { sanity: 20, family: -20 }, msg: "A verdade d√≥i. Eles olham para voc√™ com medo." },
                { text: "Mentir para proteger (Aumenta Humor, Diminui Sanidade)", effect: { sanity: -10, family: 10 }, msg: "Voc√™ guarda o fardo sozinho. A ignor√¢ncia √© uma b√™n√ß√£o." }
            ]
        },
        {
            title: "NOITE 2: O R√ÅDIO AMADOR",
            body: "Sua filha mais nova consertou um r√°dio velho. Ela diz ter ouvido uma voz chamando por 'Cobaia 7'. Esse era o seu codinome na Iniciativa Pluribus antes da Jun√ß√£o. Ela quer responder.",
            choices: [
                { text: "Permitir contato (Risco Alto)", effect: { energy: -20, door: -20 }, msg: "O sinal atraiu aten√ß√£o indesejada para a porta." },
                { text: "Destruir o r√°dio (Diminui Humor)", effect: { family: -30 }, msg: "Ela chora. O sil√™ncio retorna ao bunker." }
            ]
        },
        {
            title: "NOITE 3: A OFERTA DA CORPORA√á√ÉO",
            body: "Um drone da Lumon-Pluribus paira na ventila√ß√£o. Ele oferece c√°psulas de nutri√ß√£o perfeitas em troca de dados biom√©tricos de um dos membros da fam√≠lia. Algu√©m teria que doar sangue... muito sangue.",
            choices: [
                { text: "Aceitar a troca (Energia M√°xima, Dano Fam√≠lia)", effect: { energy: 100, family: -40 }, msg: "O drone parte com o sangue. A comida tem gosto de culpa." },
                { text: "Recusar e passar fome (Perde Energia)", effect: { energy: -30, sanity: 10 }, msg: "Voc√™s mant√™m a dignidade, mas a fome aperta." }
            ]
        },
        {
            title: "NOITE 4: O PASSADO ESQUECIDO",
            body: "Voc√™ tem um sonho v√≠vido. Antes do bunker, voc√™ n√£o era um civil. Voc√™ era um dos arquitetos da Jun√ß√£o. Voc√™ lembra de ter trancado as portas do lado de fora.",
            choices: [
                { text: "Aceitar seu passado (Perde Sanidade)", effect: { sanity: -30 }, msg: "A culpa √© esmagadora, mas real." },
                { text: "Reprimir a mem√≥ria (Gasta Energia)", effect: { energy: -20 }, msg: "Voc√™ toma p√≠lulas para dormir. O passado morre." }
            ]
        },
        {
            title: "NOITE SILENCIOSA",
            body: "A noite caiu e nada se ouve l√° fora. Apenas o zumbido do monitor e a respira√ß√£o da sua fam√≠lia. √â um momento de paz ou o prel√∫dio do fim?",
            choices: [
                { text: "Dormir (Recupera Energia)", effect: { energy: 20 }, msg: "Um descanso merecido." },
                { text: "Vigiar (Recupera Porta)", effect: { door: 20 }, msg: "Voc√™ refor√ßa as trancas enquanto eles dormem." }
            ]
        }
    ];

    const TROPHIES = {
        FIRST_BLOOD: { id: 'first_blood', title: "Primeiro Sangue", desc: "Eletrocutou um visitante.", icon: "‚ö°" },
        SAVIOR: { id: 'savior', title: "O Salvador", desc: "Salvou 3 humanos.", icon: "ü§ù" },
        SLAYER: { id: 'slayer', title: "Exterminador", desc: "Matou 3 monstros.", icon: "üíÄ" },
        SURVIVOR: { id: 'survivor', title: "Meio Caminho", desc: "Chegou ao Dia 4.", icon: "üìÖ" },
        MECHANIC: { id: 'mechanic', title: "Engenheiro", desc: "Reparou a porta ao m√°ximo.", icon: "üîß" },
        FAMILY_FIRST: { id: 'family', title: "Pai de Fam√≠lia", desc: "Manteve o humor da fam√≠lia em 100%.", icon: "‚ù§Ô∏è" },
        PLATINUM: { id: 'plat', title: "A JUN√á√ÉO PERFEITA", desc: "Coletou todos os trof√©us.", icon: "üèÜ" }
    };

    const VISITOR_TYPES = [
        { 
            id: 'survivor', type: 'good', name: 'Sobrevivente', visual: `___\n(o o)\n| - |\n-----`, 
            prompt: "Humano desesperado. Fale 10 palavras pedindo abrigo.", reward: { energy: 10, sanity: 5 }, 
            desc: "Apenas algu√©m tentando viver.",
            lines: ["Por favor, abram! Eles est√£o vindo!", "Tenho comida... troco por abrigo.", "N√£o sou um deles, juro!", "Minha perna est√° sangrando..."]
        },
        { 
            id: 'medic', type: 'good', name: 'M√©dico', visual: `___\n(o o)\n| + |\n-----`, 
            prompt: "M√©dico militar calmo.", reward: { energy: 10, sanity: 30 }, 
            desc: "Traz rem√©dios.",
            lines: ["Sou m√©dico da Divis√£o 4. Tenho penicilina.", "Posso tratar seus feridos.", "Preciso de um local seguro para operar.", "A infec√ß√£o est√° se espalhando l√° fora."]
        },
        { 
            id: 'mechanic', type: 'good', name: 'Mec√¢nico', visual: `___\n[o o]\n| # |\n-----`, 
            prompt: "Mec√¢nico pr√°tico.", reward: { energy: 10, door: 40 }, 
            desc: "Pode reparar a porta.",
            lines: ["Essa porta vai ceder logo. Posso consertar.", "Tenho ferramentas e sucata.", "O filtro de ar de voc√™s est√° falhando.", "Engenheiro N√≠vel 3 solicitando acesso."]
        },
        { 
            id: 'mimic', type: 'bad', name: 'M√≠mico', visual: `___\n(o o)\n| O |\n-----`, 
            prompt: "Monstro M√≠mico. Tente falar como humano, mas falhe.", damage: { door: 30, sanity: 30 }, 
            desc: "Finge ser gente.",
            lines: ["Abra... a... porta... amigos.", "Eu sou... humano... como... voc√™s...", "Carne... fresca... digo... abrigo.", "M√£e? Pai? Sou eu..."]
        },
        { 
            id: 'brute', type: 'bad', name: 'Brutamontes', visual: `/ \\\n(X X)\n(###)\n\\___/`, 
            prompt: "Monstro violento.", damage: { door: 60, sanity: 10 }, 
            desc: "Dano massivo na porta.",
            lines: ["GRRAAAAAH!", "ESMAGAR!", "FOME!", "(Sons de metal sendo amassado)"]
        },
        { 
            id: 'cultist', type: 'bad', name: 'Cultista', visual: ` / \\\n(o o)\n |^| \n-----`, 
            prompt: "Fan√°tico religioso.", damage: { door: 10, sanity: 50 }, 
            desc: "Drena sua sanidade.",
            lines: ["A Jun√ß√£o nos far√° um s√≥.", "Abram para a gl√≥ria do Novo Amanhecer.", "Seus genes s√£o impuros.", "O sil√™ncio √© a √∫nica salva√ß√£o."]
        }
    ];

    const STATE = {
        playing: false,
        day: 1,
        maxDays: 8,
        dayTime: 300,
        
        sanity: 80,
        energy: 80,
        doorHealth: 100,
        familyMood: 100,
        
        dailySurvivorsLetIn: 0,
        survivorsQuota: 2,
        
        // CONTROLE DE VISITA
        nextVisitorTimer: 60, // 60 segundos
        doorKnocking: false,
        visitor: null,
        lookingAtPeephole: false,
        screenView: 'BOOT', 
        currentLocation: 'BUNKER',
        gameOver: false,
        interrogated: false,
        isNarrativeMode: false,
        
        stats: { humansSaved: 0, monstersKilled: 0, unlockedTrophies: [] },
        quiz: { question: "", options: [], answer: 0, rewardType: '', rewardAmount: 0 },
        
        // MINIGAMES STATE
        minigame: {
            active: null, // 'SNAKE', 'MEMORY', 'PACMAN'
            snake: { snake: [{x:10, y:10}], dir: {x:0, y:0}, food: {x:15, y:15}, score: 0, speed: 10, tick: 0 },
            memory: { cards: [], flipped: [], matches: 0, locked: false, grid: [4, 3] },
            pacman: { 
                player: {x:1, y:1}, 
                ghost: {x:7, y:7, tick: 0, speed: 8}, // Velocidade ajustada
                score: 0, 
                map: [], 
                width: 15, 
                height: 15 
            }
        }
    };

    const LOCATIONS = {
        BUNKER: { color: 0xffcc00, fog: 0x050505, fogDens: 0.15 },
        MARKET: { color: 0x00FFFF, fog: 0x001133, fogDens: 0.3 },
        PHARMACY: { color: 0xFFFFFF, fog: 0xEEEEEE, fogDens: 0.4 },
        STREETS: { color: 0xFF6600, fog: 0x331100, fogDens: 0.6 }
    };
    const QUIZ_DATA = {
        MARKET: [{ q: "Lata sem r√≥tulo.", opt: ["Comer", "Ignorar", "Guardar"], ans: 1, type: 'energy', val: 20, fail: -10 }],
        PHARMACY: [{ q: "Soro experimental.", opt: ["Usar", "Estocar", "Destruir"], ans: 1, type: 'sanity', val: 30, fail: -20 }],
        STREETS: [{ q: "N√©voa √°cida.", opt: ["Correr", "Sinalizador", "Abrigo"], ans: 2, type: 'sanity', val: 20, fail: -40 }]
    };

    window.gameActions = {
        interrogate: () => interrogateVisitor(),
        openDoor: () => resolveDoor(true),
        shockDoor: () => resolveDoor(false),
        exitPeephole: () => exitPeepholeMode()
    };

    let camera, scene, renderer;
    let monitorTexture, monitorContext, monitorMesh;
    let pointLightPC, pointLightEmergency;
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();
    let audioCtx, masterGain;

    // --- INPUTS ---
    function onMouseMove(e) {
        if (!STATE.playing || STATE.gameOver || STATE.lookingAtPeephole || STATE.isNarrativeMode) return;
        targetYaw -= e.movementX * LOOK_SPEED;
        targetPitch -= e.movementY * LOOK_SPEED;
        targetPitch = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, targetPitch));
        targetYaw = Math.max(-MAX_YAW, Math.min(MAX_YAW, targetYaw));
    }
    
    // CONTROLE DOS MINIGAMES
    document.addEventListener('keydown', (e) => {
        if (!STATE.playing || STATE.screenView.startsWith('GAME_') === false) return;
        
        const key = e.key.toLowerCase();
        
        // Snake Controls
        if (STATE.screenView === 'GAME_SNAKE') {
            const s = STATE.minigame.snake;
            if ((key === 'arrowup' || key === 'w') && s.dir.y === 0) s.dir = {x:0, y:-1};
            if ((key === 'arrowdown' || key === 's') && s.dir.y === 0) s.dir = {x:0, y:1};
            if ((key === 'arrowleft' || key === 'a') && s.dir.x === 0) s.dir = {x:-1, y:0};
            if ((key === 'arrowright' || key === 'd') && s.dir.x === 0) s.dir = {x:1, y:0};
        }
        
        // Pacman Controls
        if (STATE.screenView === 'GAME_PACMAN') {
            const p = STATE.minigame.pacman;
            let dx = 0, dy = 0;
            if (key === 'arrowup' || key === 'w') dy = -1;
            if (key === 'arrowdown' || key === 's') dy = 1;
            if (key === 'arrowleft' || key === 'a') dx = -1;
            if (key === 'arrowright' || key === 'd') dx = 1;
            
            if (dx !== 0 || dy !== 0) {
                const nx = p.player.x + dx;
                const ny = p.player.y + dy;
                // 1 is wall
                if (p.map[ny] && p.map[ny][nx] !== 1) {
                    p.player.x = nx;
                    p.player.y = ny;
                    if (p.map[ny][nx] === 2) { // Eat dot
                        p.map[ny][nx] = 0;
                        p.score++;
                        playSound('click');
                        if (checkPacmanWin()) winMinigame();
                    }
                }
            }
        }
    });

    function updateCameraSmooth() {
        if (!STATE.playing || STATE.gameOver || STATE.lookingAtPeephole) return;
        camPitch += (targetPitch - camPitch) * SMOOTH_FACTOR;
        camYaw += (targetYaw - camYaw) * SMOOTH_FACTOR;
        camera.rotation.set(camPitch, camYaw, 0, 'YXZ');
    }

    function updateTimer(dt) {
        if (STATE.gameOver || STATE.isNarrativeMode || STATE.screenView === 'LOCATION_QUIZ' || STATE.screenView.startsWith('GAME_')) return;
        
        STATE.dayTime -= dt;
        
        // --- MEC√ÇNICA DE VISITA AGENDADA (1 MINUTO) ---
        if (STATE.currentLocation === 'BUNKER' && !STATE.doorKnocking && !STATE.isNarrativeMode) {
            STATE.nextVisitorTimer -= dt;
            if (STATE.nextVisitorTimer <= 0) {
                triggerKnockEvent();
                STATE.nextVisitorTimer = 60; // Resetar para 1 minuto
            }
        }

        if (STATE.doorKnocking) {
            const decay = 2.0 * dt; 
            STATE.doorHealth -= decay;
            if (STATE.doorHealth <= 0) checkState();
        }

        if (STATE.dayTime <= 0) {
            STATE.dayTime = 0;
            triggerEndOfDay();
        }
        
        const min = Math.floor(STATE.dayTime / 60);
        const sec = Math.floor(STATE.dayTime % 60);
        document.getElementById('timer-display').innerText = `${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
        
        if(STATE.doorKnocking) updateHUD();
    }

    function triggerEndOfDay() {
        if (STATE.dailySurvivorsLetIn < STATE.survivorsQuota) {
            triggerGameOver(`COTA N√ÉO ATINGIDA (${STATE.dailySurvivorsLetIn}/${STATE.survivorsQuota}). O Comando Central isolou seu bunker.`);
            return;
        }
        STATE.isNarrativeMode = true;
        document.exitPointerLock();
        const eventIdx = Math.min(STATE.day - 1, NARRATIVE_EVENTS.length - 1);
        const event = NARRATIVE_EVENTS[eventIdx] || NARRATIVE_EVENTS[NARRATIVE_EVENTS.length-1];
        const overlay = document.getElementById('narrative-overlay');
        const title = document.getElementById('narrative-title');
        const body = document.getElementById('narrative-body');
        const choicesDiv = document.getElementById('narrative-choices');
        const consq = document.getElementById('consequence-text');
        title.innerText = event.title;
        body.innerText = event.body;
        consq.style.opacity = 0;
        choicesDiv.innerHTML = '';
        event.choices.forEach(choice => {
            const btn = document.createElement('button');
            btn.className = 'choice-btn';
            btn.innerText = choice.text;
            btn.onclick = () => resolveNarrative(choice);
            choicesDiv.appendChild(btn);
        });
        overlay.style.display = 'flex';
        playSound('travel');
    }

    function resolveNarrative(choice) {
        if (choice.effect.sanity) STATE.sanity += choice.effect.sanity;
        if (choice.effect.energy) STATE.energy += choice.effect.energy;
        if (choice.effect.family) STATE.familyMood += choice.effect.family;
        if (choice.effect.door) STATE.doorHealth += choice.effect.door;
        STATE.sanity = Math.min(100, Math.max(0, STATE.sanity));
        STATE.energy = Math.min(100, Math.max(0, STATE.energy));
        STATE.familyMood = Math.min(100, Math.max(0, STATE.familyMood));
        STATE.doorHealth = Math.min(100, Math.max(0, STATE.doorHealth));
        const consq = document.getElementById('consequence-text');
        consq.innerText = choice.msg || "Sua fam√≠lia vai se lembrar disso.";
        consq.style.opacity = 1;
        document.getElementById('narrative-choices').innerHTML = '<button class="choice-btn" id="next-day-btn">INICIAR PR√ìXIMO DIA</button>';
        document.getElementById('next-day-btn').onclick = startNextDay;
    }

    function startNextDay() {
        document.getElementById('narrative-overlay').style.display = 'none';
        document.body.requestPointerLock();
        STATE.day++;
        STATE.dayTime = 300;
        STATE.isNarrativeMode = false;
        STATE.dailySurvivorsLetIn = 0;
        STATE.familyMood -= 10;
        STATE.energy -= 10;
        checkState();
        if (!STATE.gameOver) {
            logMessage(`DIA ${STATE.day} INICIADO. COTA: 0/${STATE.survivorsQuota}`);
        }
    }

    function unlockTrophy(key) {
        if (!TROPHIES[key]) return;
        
        // Corre√ß√£o: Usar o ID interno do trof√©u para verifica√ß√£o e armazenamento
        const trophyId = TROPHIES[key].id;
        if (STATE.stats.unlockedTrophies.includes(trophyId)) return;
        
        STATE.stats.unlockedTrophies.push(trophyId);
        
        const popup = document.getElementById('trophy-popup');
        document.getElementById('trophy-icon').innerText = TROPHIES[key].icon;
        document.getElementById('trophy-name').innerText = TROPHIES[key].title;
        popup.style.top = '20px'; setTimeout(() => popup.style.top = '-100px', 4000);
        playSound('trophy');
        if (STATE.stats.unlockedTrophies.length === Object.keys(TROPHIES).length - 1 && !STATE.stats.unlockedTrophies.includes('plat')) setTimeout(() => unlockTrophy('PLATINUM'), 2000);
    }

    function updateHUD() {
        if (!STATE.playing) return;
        document.getElementById('hud-day').innerText = `${STATE.day}/${STATE.maxDays}`;
        document.getElementById('hud-quota').innerText = `${STATE.dailySurvivorsLetIn}/${STATE.survivorsQuota}`;
        document.getElementById('hud-energy').innerText = Math.floor(STATE.energy);
        updateBar('bar-sanity', STATE.sanity, 'row-sanity');
        updateBar('bar-door', STATE.doorHealth, 'row-door');
        updateBar('bar-family', STATE.familyMood, 'row-family');
        if (STATE.day >= 4) unlockTrophy('SURVIVOR');
        if (STATE.familyMood >= 100) unlockTrophy('FAMILY_FIRST');
    }

    function updateBar(id, val, rowId) {
        document.getElementById(id).style.width = `${Math.max(0, Math.min(100, val))}%`;
        document.getElementById(rowId).classList.toggle('danger', val <= 30);
    }

    async function generateVisitorDialogue(visitor) {
        const txt = document.getElementById('dialogue-text');
        document.getElementById('dialogue-box').style.display = 'block';
        txt.innerText = "Analisando...";
        
        // MODO SEM API (FALLBACK ROBUSTO)
        if (!apiKey || apiKey === "") {
            // Seleciona uma frase aleat√≥ria do tipo de visitante
            const lines = visitor.lines || [visitor.desc];
            const line = lines[Math.floor(Math.random() * lines.length)];
            // Simula um pequeno atraso de "processamento"
            setTimeout(() => {
                typeWriterEffect(`"${line}"\n\n(AN√ÅLISE: ${visitor.name}. ${visitor.desc})`, txt);
            }, 500);
            return;
        }

        try {
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    contents: [{ parts: [{ text: visitor.prompt + " Max 12 palavras." }] }],
                    generationConfig: { maxOutputTokens: 50 } 
                })
            });
            const data = await res.json();
            const aiText = data.candidates[0].content.parts[0].text;
            typeWriterEffect(aiText, txt);
        } catch (e) { 
            // Fallback se a API falhar mesmo com chave
            const lines = visitor.lines || [visitor.desc];
            const line = lines[Math.floor(Math.random() * lines.length)];
            typeWriterEffect(`"${line}"`, txt);
        }
    }

    function typeWriterEffect(text, el) {
        el.innerText = ""; let i = 0;
        // CHANGED speed from 50 to 15 for faster typing
        function type() { if (i < text.length) { el.innerText += text.charAt(i); i++; setTimeout(type, 15); } }
        type();
    }

    function initAudio() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext(); masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.4; masterGain.connect(audioCtx.destination);
    }

    function playSound(type, pos) {
        if (!audioCtx || STATE.gameOver) return;
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        if (pos) {
            const p = audioCtx.createPanner(); p.panningModel = 'HRTF';
            p.positionX.value = pos.x; p.positionY.value = pos.y; p.positionZ.value = pos.z;
            osc.connect(gain).connect(p).connect(masterGain);
        } else osc.connect(gain).connect(masterGain);
        const now = audioCtx.currentTime;
        if (type === 'click') { osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now+0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now+0.1); osc.start(now); osc.stop(now+0.1); }
        else if (type === 'trophy') { osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+1); osc.start(now); osc.stop(now+1); }
        else if (type === 'travel') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now+2); gain.gain.value = 0.1; osc.start(now); osc.stop(now+2); }
        else if (type === 'hum') { osc.type = 'sine'; osc.frequency.value = 60; gain.gain.value = 0.05; osc.start(now); }
        else if (type === 'knock') { osc.type = 'triangle'; osc.frequency.setValueAtTime(60, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.2); gain.gain.setValueAtTime(1, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.3); osc.start(now); osc.stop(now+0.3); }
        else if (type === 'shock') { osc.type = 'sawtooth'; osc.frequency.linearRampToValueAtTime(1000, now+0.5); gain.gain.setValueAtTime(0.5, now); osc.start(now); osc.stop(now+0.5); }
        else if (type === 'jumpscare') { osc.type = 'sawtooth'; osc.frequency.value = 50; gain.gain.value = 1; osc.start(now); osc.stop(now+2); }
    }

    function updateEnvironment3D() {
        const t = LOCATIONS[STATE.currentLocation];
        pointLightPC.color.lerp(new THREE.Color(t.color), 0.05);
        scene.fog.color.lerp(new THREE.Color(t.fog), 0.05);
        scene.fog.density = THREE.MathUtils.lerp(scene.fog.density, t.fogDens, 0.02);
    }

    const CANVAS_W = 512, CANVAS_H = 512, CRT_COLOR = '#ffcc00';
    let osButtons = [];

    function initMonitorOS() {
        const c = document.createElement('canvas'); c.width = CANVAS_W; c.height = CANVAS_H;
        monitorContext = c.getContext('2d');
        monitorTexture = new THREE.CanvasTexture(c);
        monitorTexture.minFilter = THREE.LinearFilter; monitorTexture.magFilter = THREE.NearestFilter;
    }

    function drawButton(ctx, x, y, w, h, text) {
        ctx.strokeStyle = CRT_COLOR; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
        ctx.fillStyle = CRT_COLOR; ctx.font = '18px monospace'; ctx.fillText(text, x + 10, y + 25);
        return { x, y, w, h };
    }

    function drawOS() {
        const ctx = monitorContext; if (!ctx) return;
        ctx.fillStyle = '#110d00'; ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.shadowBlur = 4; ctx.shadowColor = CRT_COLOR; ctx.fillStyle = CRT_COLOR;
        osButtons = [];

        // --- MINIGAME LOOPS ---
        if (STATE.screenView === 'GAME_SNAKE') updateAndDrawSnake(ctx);
        else if (STATE.screenView === 'GAME_MEMORY') drawMemory(ctx);
        else if (STATE.screenView === 'GAME_PACMAN') updateAndDrawPacman(ctx);

        // --- SCREENS ---
        else if (STATE.screenView === 'DESKTOP') {
            ctx.font = '28px monospace'; ctx.fillText(`PLURIBUS OS v9.0`, 40, 50);
            if (STATE.doorKnocking) { ctx.fillStyle = 'red'; ctx.shadowColor = 'red'; ctx.fillText("ALERTA DE SEGURAN√áA", 120, 450); ctx.fillStyle = CRT_COLOR; ctx.shadowColor = CRT_COLOR; }
            osButtons.push({ action: 'GO_MAP', ...drawButton(ctx, 40, 100, 430, 50, "EXPEDI√á√ÉO") });
            osButtons.push({ action: 'GO_FAMILY', ...drawButton(ctx, 40, 170, 430, 50, "FAM√çLIA") });
            osButtons.push({ action: 'GO_REPAIR', ...drawButton(ctx, 40, 240, 200, 50, "MANUTEN√á√ÉO") });
            osButtons.push({ action: 'GO_GAMES', ...drawButton(ctx, 270, 240, 200, 50, "JOGOS") }); // New Button
            osButtons.push({ action: 'GO_TROPHIES', ...drawButton(ctx, 40, 310, 200, 50, "TROF√âUS") });
            osButtons.push({ action: 'MAIL', ...drawButton(ctx, 270, 310, 200, 50, "DI√ÅRIO") });
        }
        else if (STATE.screenView === 'GAMES_MENU') {
            ctx.fillText("JOGOS - RECUPERAR SANIDADE", 40, 50);
            osButtons.push({ action: 'START_SNAKE', ...drawButton(ctx, 40, 100, 430, 50, "COBRINHA") });
            osButtons.push({ action: 'START_MEMORY', ...drawButton(ctx, 40, 170, 430, 50, "MEM√ìRIA") });
            osButtons.push({ action: 'START_PACMAN', ...drawButton(ctx, 40, 240, 430, 50, "LABIRINTO") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'TROPHIES') {
            ctx.fillText("COLE√á√ÉO DE TROF√âUS", 40, 50); let y = 100;
            Object.values(TROPHIES).forEach(t => {
                const un = STATE.stats.unlockedTrophies.includes(t.id);
                ctx.fillStyle = un ? CRT_COLOR : '#554400'; ctx.fillText(`${un ? `[X] ${t.icon}` : `[ ] üîí`} ${t.title}`, 40, y); y += 30;
            });
            ctx.fillStyle = CRT_COLOR; osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'FAMILY') {
            ctx.fillText("STATUS DA FAM√çLIA", 40, 50);
            ctx.fillText(`HUMOR: ${STATE.familyMood}%`, 40, 90);
            osButtons.push({ action: 'FAM_FEED', ...drawButton(ctx, 40, 200, 430, 50, "DAR RA√á√ÉO (20 EN)") });
            osButtons.push({ action: 'FAM_TALK', ...drawButton(ctx, 40, 270, 430, 50, "CONVERSAR (10 EN)") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'REPAIR') {
            ctx.fillText("MANUTEN√á√ÉO", 40, 50);
            ctx.fillText(`INTEGRIDADE: ${STATE.doorHealth.toFixed(1)}%`, 40, 90);
            osButtons.push({ action: 'REP_DOOR', ...drawButton(ctx, 40, 200, 430, 50, "REPARAR (30 EN)") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'MAP') {
            ctx.fillText("DESTINO DA EXPEDI√á√ÉO:", 40, 50);
            osButtons.push({ action: 'GO_MARKET', ...drawButton(ctx, 40, 100, 430, 50, "MERCADO") });
            osButtons.push({ action: 'GO_PHARMA', ...drawButton(ctx, 40, 170, 430, 50, "FARM√ÅCIA") });
            osButtons.push({ action: 'GO_STREET', ...drawButton(ctx, 40, 240, 430, 50, "RUAS") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 400, 100, 40, "CANCELAR") });
        }
        else if (STATE.screenView === 'LOCATION_QUIZ') {
            ctx.fillText(`LOCAL: ${STATE.currentLocation}`, 40, 40);
            const w = STATE.quiz.question.split(' '); let l = '', y = 80;
            w.forEach(word => { if (ctx.measureText(l + word).width > 450) { ctx.fillText(l, 40, y); l = word + ' '; y += 25; } else l += word + ' '; });
            ctx.fillText(l, 40, y);
            STATE.quiz.options.forEach((opt, i) => osButtons.push({ action: `ANS_${i}`, ...drawButton(ctx, 40, 200 + (i * 70), 430, 50, `${i+1}. ${opt}`) }));
        }
        else if (STATE.screenView === 'RESULT') {
            ctx.fillText("RESULTADO:", 40, 100); ctx.fillText(STATE.quiz.resultMsg, 40, 150);
        }
        else if (STATE.screenView === 'BOOT') {
            ctx.fillText("INICIALIZANDO...", 40, 100); if (Math.random() > 0.9) STATE.screenView = 'DESKTOP';
        }
        else if (STATE.screenView === 'MAIL') {
            ctx.fillText("DI√ÅRIO:", 40, 50);
            ctx.fillText("- M√≠micos podem parecer humanos.", 40, 100);
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }

        ctx.fillStyle = "rgba(255, 200, 0, 0.1)"; for (let i = 0; i < CANVAS_H; i += 4) ctx.fillRect(0, i, CANVAS_W, 2);
        monitorTexture.needsUpdate = true;
    }
    
    // --- MINIGAME LOGIC ---
    
    function winMinigame() {
        STATE.sanity = Math.min(100, STATE.sanity + 15);
        playSound('trophy');
        STATE.quiz.resultMsg = "VIT√ìRIA! SANIDADE +15";
        STATE.screenView = 'RESULT';
        setTimeout(() => { STATE.screenView = 'GAMES_MENU'; }, 2000);
    }

    function initSnake() {
        STATE.minigame.snake = { snake: [{x:10, y:10}], dir: {x:1, y:0}, food: {x:15, y:15}, score: 0, speed: 10, tick: 0 };
        STATE.screenView = 'GAME_SNAKE';
    }
    function updateAndDrawSnake(ctx) {
        const s = STATE.minigame.snake;
        ctx.fillText(`SCORE: ${s.score}/5`, 20, 30);
        ctx.fillStyle = CRT_COLOR;
        osButtons.push({ action: 'BACK_GAME', ...drawButton(ctx, 380, 450, 100, 40, "SAIR") });

        s.tick++;
        if (s.tick > s.speed) {
            s.tick = 0;
            const head = { x: s.snake[0].x + s.dir.x, y: s.snake[0].y + s.dir.y };
            
            // Collision Wall
            if (head.x < 0 || head.x >= 25 || head.y < 0 || head.y >= 25) { playSound('shock'); initSnake(); return; }
            
            // Collision Self
            for(let p of s.snake) if(head.x===p.x && head.y===p.y) { playSound('shock'); initSnake(); return; }

            s.snake.unshift(head);
            
            // Eat Food
            if (head.x === s.food.x && head.y === s.food.y) {
                s.score++;
                s.food = { x: Math.floor(Math.random()*25), y: Math.floor(Math.random()*25) };
                playSound('click');
                if (s.score >= 5) winMinigame();
            } else {
                s.snake.pop();
            }
        }

        // Draw
        const size = 18;
        ctx.fillStyle = CRT_COLOR;
        s.snake.forEach(p => ctx.fillRect(20 + p.x * size, 50 + p.y * size, size-2, size-2));
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(20 + s.food.x * size, 50 + s.food.y * size, size-2, size-2);
    }

    function initMemory() {
        const icons = ['A', 'B', 'C', 'D', 'E', 'F'];
        let cards = [...icons, ...icons];
        cards = cards.sort(() => Math.random() - 0.5).map((val, i) => ({ id: i, val, flipped: false, matched: false }));
        STATE.minigame.memory = { cards, flipped: [], matches: 0, locked: false };
        STATE.screenView = 'GAME_MEMORY';
    }
    function drawMemory(ctx) {
        ctx.fillText(`PARES: ${STATE.minigame.memory.matches}/6`, 20, 30);
        osButtons.push({ action: 'BACK_GAME', ...drawButton(ctx, 380, 450, 100, 40, "SAIR") });
        
        const cols = 4; const size = 80; const gap = 10;
        STATE.minigame.memory.cards.forEach((card, i) => {
            const c = i % cols; const r = Math.floor(i / cols);
            const x = 50 + c * (size + gap); const y = 60 + r * (size + gap);
            
            osButtons.push({ action: `MEM_${i}`, x, y, w: size, h: size });
            
            ctx.strokeStyle = CRT_COLOR; ctx.strokeRect(x, y, size, size);
            if (card.flipped || card.matched) {
                ctx.fillStyle = card.matched ? '#00ff00' : CRT_COLOR;
                ctx.font = '40px monospace';
                ctx.fillText(card.val, x + 25, y + 55);
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(x+5, y+5, size-10, size-10);
            }
        });
    }
    function handleMemoryClick(idx) {
        const m = STATE.minigame.memory;
        if (m.locked || m.cards[idx].flipped || m.cards[idx].matched) return;
        
        m.cards[idx].flipped = true;
        m.flipped.push(idx);
        playSound('click');

        if (m.flipped.length === 2) {
            m.locked = true;
            const c1 = m.cards[m.flipped[0]];
            const c2 = m.cards[m.flipped[1]];
            
            if (c1.val === c2.val) {
                c1.matched = true; c2.matched = true;
                m.flipped = []; m.locked = false; m.matches++;
                playSound('click');
                if (m.matches === 6) winMinigame();
            } else {
                setTimeout(() => {
                    c1.flipped = false; c2.flipped = false;
                    m.flipped = []; m.locked = false;
                    playSound('shock');
                }, 800);
            }
        }
    }

    function initPacman() {
        // 0: empty, 1: wall, 2: dot
        // Simple 15x15 maze
        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,2,2,2,2,1,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,2,1],
            [1,2,1,2,2,2,2,2,2,2,2,1,2,2,1],
            [1,2,1,2,1,1,1,1,1,1,2,1,2,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,0,1,1,2,1,1,2,1], // Center empty
            [1,2,2,2,2,1,0,0,0,1,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,1,1,2,1],
            [1,2,2,2,1,2,2,1,2,2,1,2,2,2,1],
            [1,1,1,2,1,1,2,1,2,1,1,2,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        let totalDots = 0;
        map.forEach(row => row.forEach(cell => { if(cell===2) totalDots++; }));
        STATE.minigame.pacman = { 
            player: {x:1, y:1}, 
            ghost: {x:7, y:7, tick: 0, speed: 8}, // Fantasma
            score: 0, totalDots, map, width: 15, height: 15 
        };
        STATE.screenView = 'GAME_PACMAN';
    }
    
    function checkPacmanWin() { return STATE.minigame.pacman.score >= STATE.minigame.pacman.totalDots; }
    
    function updateAndDrawPacman(ctx) {
        const p = STATE.minigame.pacman;
        ctx.fillText(`DOTS: ${p.score}/${p.totalDots}`, 20, 30);
        osButtons.push({ action: 'BACK_GAME', ...drawButton(ctx, 380, 450, 100, 40, "SAIR") });

        const size = 25;
        const offsetX = 60; const offsetY = 50;

        // --- L√ìGICA DO FANTASMA (BFS) ---
        p.ghost.tick++;
        if (p.ghost.tick > p.ghost.speed) {
            p.ghost.tick = 0;
            
            // BFS para encontrar o pr√≥ximo passo
            const startNode = {x: p.ghost.x, y: p.ghost.y};
            const targetNode = {x: p.player.x, y: p.player.y};
            
            // Queue stores paths: [ {x,y}, {x,y}, ... ]
            let queue = [ [startNode] ];
            let visited = new Set();
            visited.add(`${startNode.x},${startNode.y}`);
            
            let nextMove = null;
            
            // Limite de itera√ß√µes para n√£o travar se n√£o houver caminho (seguran√ßa)
            let iterations = 0;
            
            while (queue.length > 0 && iterations < 300) {
                iterations++;
                let path = queue.shift();
                let current = path[path.length - 1];
                
                if (current.x === targetNode.x && current.y === targetNode.y) {
                    // Caminho encontrado! O pr√≥ximo passo √© o segundo elemento do caminho (√≠ndice 1)
                    // √çndice 0 √© a posi√ß√£o atual do fantasma
                    if (path.length > 1) {
                        nextMove = path[1];
                    }
                    break;
                }
                
                // Vizinhos: Cima, Baixo, Esquerda, Direita
                const neighbors = [
                    {x: current.x, y: current.y - 1},
                    {x: current.x, y: current.y + 1},
                    {x: current.x - 1, y: current.y},
                    {x: current.x + 1, y: current.y}
                ];
                
                for (let neighbor of neighbors) {
                    // Check bounds and walls
                    if (neighbor.x >= 0 && neighbor.x < p.width && 
                        neighbor.y >= 0 && neighbor.y < p.height &&
                        p.map[neighbor.y][neighbor.x] !== 1) {
                            
                        const key = `${neighbor.x},${neighbor.y}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            let newPath = [...path, neighbor];
                            queue.push(newPath);
                        }
                    }
                }
            }
            
            if (nextMove) {
                p.ghost.x = nextMove.x;
                p.ghost.y = nextMove.y;
            }
            
            // Colis√£o com Jogador (Game Over do Minigame)
            if (p.ghost.x === p.player.x && p.ghost.y === p.player.y) {
                playSound('shock');
                initPacman(); // Reinicia o jogo
                return;
            }
        }

        for(let y=0; y<p.height; y++) {
            for(let x=0; x<p.width; x++) {
                const type = p.map[y][x];
                const px = offsetX + x * size;
                const py = offsetY + y * size;
                if (type === 1) { // Wall
                    ctx.fillStyle = '#3333cc';
                    ctx.fillRect(px, py, size, size);
                } else if (type === 2) { // Dot
                    ctx.fillStyle = '#ffcc00';
                    ctx.fillRect(px + 10, py + 10, 5, 5);
                }
            }
        }
        
        // Draw Ghost (Red)
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(offsetX + p.ghost.x * size + size/2, offsetY + p.ghost.y * size + size/2, size/2 - 2, 0, 2 * Math.PI);
        ctx.fill();

        // Draw Player (Yellow)
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(offsetX + p.player.x * size + size/2, offsetY + p.player.y * size + size/2, size/2 - 2, 0.2 * Math.PI, 1.8 * Math.PI);
        ctx.lineTo(offsetX + p.player.x * size + size/2, offsetY + p.player.y * size + size/2);
        ctx.fill();
    }

    // --- END MINIGAME LOGIC ---

    function startExpedition(loc) {
        STATE.currentLocation = loc; playSound('travel');
        const p = QUIZ_DATA[loc]; const q = p[Math.floor(Math.random()*p.length)];
        STATE.quiz = { question: q.q, options: q.opt, answer: q.ans, rewardType: q.type, rewardAmount: q.val, failAmount: q.fail };
        STATE.screenView = 'LOCATION_QUIZ';
    }

    function handleQuizAnswer(idx) {
        const ok = idx === STATE.quiz.answer;
        if (ok) {
            STATE[STATE.quiz.rewardType] = Math.min(100, STATE[STATE.quiz.rewardType] + STATE.quiz.rewardAmount);
            playSound('click'); STATE.quiz.resultMsg = "SUCESSO!";
        } else {
            STATE.energy = Math.max(0, STATE.energy - 10); STATE.sanity = Math.max(0, STATE.sanity + STATE.quiz.failAmount);
            playSound('shock'); STATE.quiz.resultMsg = "FALHA.";
        }
        STATE.screenView = 'RESULT'; setTimeout(() => { STATE.screenView = 'DESKTOP'; STATE.currentLocation = 'BUNKER'; }, 2000);
    }

    function checkState() {
        if (STATE.day > STATE.maxDays) { document.body.innerHTML = `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;background:black;color:#ffcc00;font-family:monospace;"><h1>DIA 8: RESGATE CHEGOU</h1><p>Voc√™ sobreviveu.</p><button onclick="location.reload()">REINICIAR</button></div>`; STATE.playing = false; }
        else if (STATE.energy <= 0) triggerGameOver("Sem Energia.");
        else if (STATE.sanity <= 0) triggerGameOver("Loucura Total.");
        else if (STATE.doorHealth <= 0) triggerGameOver("Porta Destru√≠da.");
        else if (STATE.familyMood <= 0) triggerGameOver("Motim Familiar.");
    }

    function triggerGameOver(r) {
        STATE.gameOver = true; playSound('jumpscare'); document.getElementById('vhs-overlay').style.background = 'red';
        setTimeout(() => document.body.innerHTML = `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;background:black;color:red;font-family:monospace;text-align:center;"><h1>FIM DE JOGO</h1><p>${r}</p><button onclick="location.reload()">REINICIAR</button></div>`, 2000);
    }

    function handleMonitorClick(uv) {
        const x = uv.x * CANVAS_W, y = (1 - uv.y) * CANVAS_H; 
        // Only play click sound if not in game mode (prevent audio spam) or if pressing UI buttons
        let clickedUI = false;

        for (let btn of osButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                clickedUI = true;
                playSound('click');
                if (btn.action === 'GO_MAP') STATE.screenView = 'MAP';
                else if (btn.action === 'GO_FAMILY') STATE.screenView = 'FAMILY';
                else if (btn.action === 'GO_REPAIR') STATE.screenView = 'REPAIR';
                else if (btn.action === 'GO_TROPHIES') STATE.screenView = 'TROPHIES';
                else if (btn.action === 'GO_GAMES') STATE.screenView = 'GAMES_MENU';
                else if (btn.action === 'START_SNAKE') initSnake();
                else if (btn.action === 'START_MEMORY') initMemory();
                else if (btn.action === 'START_PACMAN') initPacman();
                else if (btn.action === 'BACK_GAME') STATE.screenView = 'GAMES_MENU';
                else if (btn.action === 'MAIL') STATE.screenView = 'MAIL';
                else if (btn.action === 'BACK') STATE.screenView = 'DESKTOP';
                else if (btn.action === 'FAM_FEED' && STATE.energy >= 20) { STATE.energy -= 20; STATE.familyMood = Math.min(100, STATE.familyMood + 30); }
                else if (btn.action === 'FAM_TALK' && STATE.energy >= 10) { STATE.energy -= 10; STATE.sanity = Math.min(100, STATE.sanity + 10); }
                else if (btn.action === 'REP_DOOR' && STATE.energy >= 30) { STATE.energy -= 30; STATE.doorHealth = Math.min(100, STATE.doorHealth + 40); unlockTrophy('MECHANIC'); }
                else if (btn.action === 'GO_MARKET') startExpedition('MARKET');
                else if (btn.action === 'GO_PHARMA') startExpedition('PHARMACY');
                else if (btn.action === 'GO_STREET') startExpedition('STREETS');
                else if (btn.action.startsWith('ANS_')) handleQuizAnswer(parseInt(btn.action.split('_')[1]));
                else if (btn.action.startsWith('MEM_')) handleMemoryClick(parseInt(btn.action.split('_')[1]));
            }
        }
    }

    function triggerKnockEvent() {
        if (STATE.doorKnocking || STATE.currentLocation !== 'BUNKER' || STATE.isNarrativeMode) return;
        STATE.doorKnocking = true;
        STATE.visitor = VISITOR_TYPES[Math.floor(Math.random() * VISITOR_TYPES.length)];
        STATE.interrogated = false; playSound('knock', {x: 3, y: 1, z: 0});
        updateHUD();
        const b = setInterval(() => { if (!STATE.doorKnocking) { clearInterval(b); pointLightEmergency.intensity = 0; return; } pointLightEmergency.intensity = pointLightEmergency.intensity > 0 ? 0 : 3; }, 600);
        logMessage(`ALERTA NA PORTA.`);
    }

    function resolveDoor(open) {
        STATE.doorKnocking = false; pointLightEmergency.intensity = 0; exitPeepholeMode();
        if (open) {
            if (STATE.visitor.type === 'good') {
                if (STATE.visitor.reward.energy) STATE.energy += STATE.visitor.reward.energy;
                if (STATE.visitor.reward.sanity) STATE.sanity += STATE.visitor.reward.sanity;
                if (STATE.visitor.reward.door) STATE.doorHealth += STATE.visitor.reward.door;
                STATE.dailySurvivorsLetIn++;
                STATE.stats.humansSaved++; if (STATE.stats.humansSaved >= 3) unlockTrophy('SAVIOR');
                playSound('click'); logMessage("Acesso permitido.");
            } else {
                STATE.doorHealth -= STATE.visitor.damage.door; STATE.sanity -= STATE.visitor.damage.sanity;
                playSound('shock'); logMessage("ERRO! Intruso!");
            }
        } else {
            playSound('shock', {x: 3, y: 1, z: 0}); unlockTrophy('FIRST_BLOOD');
            if (STATE.visitor.type === 'good') { STATE.sanity -= 20; logMessage("Inocente eletrocutado."); }
            else { STATE.sanity += 10; STATE.stats.monstersKilled++; if (STATE.stats.monstersKilled >= 3) unlockTrophy('SLAYER'); logMessage("Amea√ßa eliminada."); }
        }
        STATE.energy = Math.min(100, STATE.energy); STATE.sanity = Math.min(100, STATE.sanity);
        STATE.doorHealth = Math.min(100, STATE.doorHealth);
        checkState();
    }

    function enterPeepholeMode() {
        if (!STATE.doorKnocking) { logMessage("Ningu√©m."); return; }
        STATE.lookingAtPeephole = true; document.exitPointerLock();
        document.getElementById('peephole-ui').style.display = 'block'; document.getElementById('dialogue-box').style.display = 'none';
        document.getElementById('visitor-visual').innerText = STATE.visitor.visual;
        camera.position.set(2.5, 1.6, 0); camera.lookAt(4, 1.6, 0);
    }
    
    function exitPeepholeMode() {
        STATE.lookingAtPeephole = false; document.getElementById('peephole-ui').style.display = 'none';
        document.body.requestPointerLock(); 
        camPitch = 0; camYaw = 0; targetPitch = 0; targetYaw = 0;
        camera.position.set(0, 1.2, 2); camera.lookAt(0, 1.2, 0);
    }
    
    function interrogateVisitor() {
        if (STATE.interrogated) return; STATE.interrogated = true; generateVisitorDialogue(STATE.visitor);
    }
    
    function logMessage(msg) {
        const el = document.getElementById('message-log'); el.innerText = `> ${msg}`; el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 3000);
    }

    function init3D() {
        const c = document.getElementById('game-container');
        scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050505, 0.15);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100); camera.position.set(0, 1.2, 2);
        renderer = new THREE.WebGLRenderer({ antialias: false }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; c.appendChild(renderer.domElement);
        const w = createNoiseMaterial(0x444444); const r = new THREE.Mesh(new THREE.BoxGeometry(6,4,6), w); r.material.side = THREE.BackSide; scene.add(r);
        const d = new THREE.Mesh(new THREE.BoxGeometry(2.5,0.1,1.5), createNoiseMaterial(0x333333)); d.position.set(0,0.8,0); scene.add(d);
        initMonitorOS(); monitorMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.6,0.6), new THREE.MeshBasicMaterial({map:monitorTexture, side:THREE.DoubleSide})); monitorMesh.position.set(0,1.2,0.31); monitorMesh.name="MONITOR"; scene.add(monitorMesh);
        const dr = new THREE.Mesh(new THREE.BoxGeometry(0.1,2.2,1.2), new THREE.MeshStandardMaterial({color:0x2a2a2a})); dr.position.set(2.95,1.1,0); dr.name="DOOR"; scene.add(dr);
        const pp = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,0.15,16), new THREE.MeshBasicMaterial({color:0x000})); pp.rotation.z=Math.PI/2; pp.position.set(2.90,1.6,0); pp.name="PEEPHOLE"; scene.add(pp);
        scene.add(new THREE.AmbientLight(0x111111));
        pointLightPC = new THREE.PointLight(0xffcc00, 1, 4); pointLightPC.position.set(0,1.2,0.5); scene.add(pointLightPC);
        pointLightEmergency = new THREE.PointLight(0xff0000, 0, 15); pointLightEmergency.position.set(2.5,2.8,0); scene.add(pointLightEmergency);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('click', () => {
            if(!STATE.playing || STATE.gameOver || STATE.lookingAtPeephole) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const h = raycaster.intersectObjects(scene.children);
            if(h.length){ if(h[0].object.name==="MONITOR") handleMonitorClick(h[0].uv); else if(h[0].object.name==="PEEPHOLE" || h[0].object.name==="DOOR") enterPeepholeMode(); }
        });
    }

    function createNoiseMaterial(c) {
        const cv = document.createElement('canvas'); cv.width=64; cv.height=64;
        const x = cv.getContext('2d'); x.fillStyle = '#'+c.toString(16); x.fillRect(0,0,64,64);
        for(let i=0;i<500;i++){ x.fillStyle=`rgba(0,0,0,${Math.random()*0.2})`; x.fillRect(Math.random()*64,Math.random()*64,2,2); }
        return new THREE.MeshStandardMaterial({map:new THREE.CanvasTexture(cv), roughness:0.9});
    }

    function animate() {
        requestAnimationFrame(animate); if(!STATE.playing || STATE.gameOver) return;
        const dt = clock.getDelta();
        updateTimer(dt);
        updateCameraSmooth();
        updateEnvironment3D(); updateHUD(); drawOS();
        // REMOVED RANDOM KNOCK HERE (Handled in updateTimer)
        // if(STATE.currentLocation === 'BUNKER' && !STATE.doorKnocking && !STATE.lookingAtPeephole && Math.random() < 0.001) triggerKnockEvent();
        renderer.render(scene, camera);
    }

    document.getElementById('overlay').addEventListener('click', () => {
        document.getElementById('overlay').style.display = 'none';
        document.body.requestPointerLock();
        initAudio(); init3D(); playSound('hum');
        STATE.playing = true; clock.start(); animate();
    });
</script>
</body>
</html>