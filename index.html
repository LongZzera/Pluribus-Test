<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLURIBUS: A JUN√á√ÉO | The Bunker Experience</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        
        /* --- UI GERAL --- */
        #overlay, #narrative-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #ffcc00; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000;
            cursor: pointer; text-align: center;
        }
        #narrative-overlay { display: none; cursor: default; background: rgba(0,0,0,0.95); z-index: 2000; }
        
        #overlay h1 { text-shadow: 0 0 10px #ffcc00; margin-bottom: 10px; }
        #overlay p { opacity: 0.8; max-width: 600px; line-height: 1.5; }

        /* Estilo Telltale */
        .narrative-title { font-size: 32px; margin-bottom: 20px; color: #fff; text-transform: uppercase; letter-spacing: 4px; border-bottom: 2px solid #ffcc00; padding-bottom: 10px; }
        .narrative-body { font-size: 18px; max-width: 700px; color: #ddd; margin-bottom: 40px; line-height: 1.6; }
        .narrative-choices { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .choice-btn {
            background: transparent; border: 2px solid #555; color: #aaa;
            padding: 15px 30px; font-family: 'Courier New'; font-size: 16px;
            cursor: pointer; transition: 0.3s; min-width: 200px;
        }
        .choice-btn:hover { border-color: #ffcc00; color: #ffcc00; background: rgba(255, 204, 0, 0.1); }
        .consequence-text { margin-top: 20px; font-style: italic; color: #ff3333; opacity: 0; transition: opacity 1s; }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 50;
            mix-blend-mode: difference;
        }

        /* --- NOTIFICA√á√ÉO DE TROF√âU --- */
        #trophy-popup {
            position: absolute; top: -100px; left: 50px; 
            width: 300px; height: 60px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 40px;
            border-left: 5px solid #ffcc00;
            display: flex; align-items: center; padding: 10px 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            transition: top 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 2000; pointer-events: none;
        }
        #trophy-icon {
            width: 40px; height: 40px; border-radius: 50%;
            background: #ffcc00; color: #000;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 20px; margin-right: 15px;
        }
        #trophy-text h4 { margin: 0; color: #fff; font-size: 14px; font-family: sans-serif; }
        #trophy-text p { margin: 0; color: #aaa; font-size: 12px; font-family: sans-serif; }

        /* --- HUD DE STATUS --- */
        #hud-overlay {
            position: absolute; top: 20px; right: 20px; width: 250px;
            padding: 15px; background: rgba(20, 20, 0, 0.1);
            border: 2px solid #ffcc00; color: #ffcc00;
            font-family: 'Courier New', monospace; font-size: 14px;
            z-index: 95; pointer-events: none;
            box-shadow: 0 0 10px rgba(255, 204, 0, 0.2);
        }
        .hud-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .hud-label { font-weight: bold; }
        .hud-bar-container { width: 100px; height: 10px; background: #111; border: 1px solid #554400; margin-top: 4px; }
        .hud-bar-fill { height: 100%; background: #ffcc00; transition: width 0.3s; }
        .danger { color: #ff3333; }
        .danger .hud-bar-fill { background: #ff3333; }
        #timer-display { font-size: 20px; font-weight: bold; text-align: center; margin-bottom: 10px; color: #fff; text-shadow: 0 0 5px #ffcc00; }
        .hud-quota-val { color: #fff; font-weight: bold; }

        /* --- EFEITOS VHS/CRT --- */
        #vhs-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 90;
            background: linear-gradient(rgba(18, 16, 0, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 200, 0, 0.06), rgba(255, 200, 0, 0.02), rgba(255, 200, 0, 0.06));
            background-size: 100% 2px, 3px 100%;
            box-shadow: inset 0 0 150px rgba(0,0,0,0.9);
        }
        #scanline {
            width: 100%; height: 10px; background: rgba(255,200,0,0.05); opacity: 0.1;
            position: absolute; z-index: 91; pointer-events: none;
            animation: scanline 6s linear infinite;
        }
        @keyframes scanline { 0% { top: -10%; } 100% { top: 110%; } }
        
        #message-log {
            position: absolute; bottom: 20px; left: 20px; color: #ffcc00;
            font-size: 14px; opacity: 0.8; pointer-events: none; z-index: 80;
            text-shadow: 1px 1px 2px black;
        }

        #peephole-ui {
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 200;
            background: radial-gradient(circle, transparent 10%, black 70%); 
            pointer-events: auto;
        }

        #visitor-visual {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: monospace; font-size: 14px; color: #ffcc00; white-space: pre;
            text-align: center; opacity: 0.8; filter: blur(1px);
            pointer-events: none;
        }

        #dialogue-box {
            position: absolute; bottom: 150px; left: 50%; transform: translateX(-50%);
            width: 600px; background: rgba(20, 15, 0, 0.9); border: 2px solid #ffcc00;
            padding: 15px; color: #ffcc00; font-family: 'Courier New'; display: none;
            text-align: center;
        }
        
        .typing-effect::after { content: '‚ñå'; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #door-controls {
            position: absolute; bottom: 50px; width: 100%; display: flex; 
            justify-content: center; gap: 20px; pointer-events: auto;
        }

        .door-btn {
            background: #111; border: 2px solid #555; color: #aaa; padding: 15px 30px;
            font-family: 'Courier New'; font-weight: bold; cursor: pointer;
            transition: 0.2s; text-transform: uppercase; letter-spacing: 2px;
        }
        .door-btn:hover { color: #fff; border-color: #fff; }
        .btn-interrogate { border-color: #ffcc00; color: #ffcc00; }
        .btn-interrogate:hover { background: #332200; }
        .btn-open { border-color: #aaaa00; color: #ffff00; }
        .btn-open:hover { background: #333300; }
        .btn-shock { border-color: #ff3333; color: #ff3333; }
        .btn-shock:hover { background: #330000; }

    </style>
</head>
<body>

<div id="overlay">
    <h1>PLURIBUS: A JUN√á√ÉO</h1>
    <p>MODO HIST√ìRIA: SOBREVIV√äNCIA DE 8 DIAS</p>
    <br>
    <p style="font-size: 12px; color: #aa8800;">[CLIQUE PARA INICIAR]</p>
    <br>
    <p>
        <b>OBJETIVO:</b> Sobreviva at√© o Dia 8.<br>
        <b>COTA:</b> Verifique a cota di√°ria no monitor.<br>
        <b>NOVOS M√âTODOS:</b> Resgate em expedi√ß√µes, r√°dio ou decodifique arquivos.
    </p>
</div>

<!-- NARRATIVE OVERLAY (TELLTALE STYLE) -->
<div id="narrative-overlay">
    <div class="narrative-title" id="narrative-title">NOITE 1: O SINAL</div>
    <div class="narrative-body" id="narrative-body">
        O sistema de r√°dio captou uma transmiss√£o antiga da Iniciativa Pluribus. 
        Parece ser um c√≥digo de ativa√ß√£o para as unidades rob√≥ticas da cidade.
        Sua fam√≠lia acha que isso pode nos salvar, mas ativar o sinal pode revelar nossa posi√ß√£o.
    </div>
    <div class="narrative-choices" id="narrative-choices">
        <!-- Buttons injected via JS -->
    </div>
    <div class="consequence-text" id="consequence-text">Sua fam√≠lia vai se lembrar disso.</div>
</div>

<div id="game-container">
    <div id="vhs-overlay"></div>
    <div id="scanline"></div>
    <div id="crosshair"></div>
    
    <div id="trophy-popup">
        <div id="trophy-icon">üèÜ</div>
        <div id="trophy-text">
            <h4>Conquista Desbloqueada</h4>
            <p id="trophy-name">Nome do Trof√©u</p>
        </div>
    </div>

    <div id="hud-overlay">
        <div id="timer-display">05:00</div>
        <div class="hud-row">
            <span class="hud-label">DIA:</span>
            <span id="hud-day">1/8</span>
        </div>
        <!-- NOVA LINHA DE COTA -->
        <div class="hud-row">
            <span class="hud-label">COTA DI√ÅRIA:</span>
            <span id="hud-quota" class="hud-quota-val">0/2</span>
        </div>
        <div class="hud-row" id="row-sanity">
            <span class="hud-label">SANIDADE:</span>
            <div class="hud-bar-container"><div id="bar-sanity" class="hud-bar-fill" style="width: 80%"></div></div>
        </div>
        <div class="hud-row" id="row-door">
            <span class="hud-label">PORTA:</span>
            <div class="hud-bar-container"><div id="bar-door" class="hud-bar-fill" style="width: 100%"></div></div>
        </div>
        <div class="hud-row" id="row-family">
            <span class="hud-label">FAM√çLIA:</span>
            <div class="hud-bar-container"><div id="bar-family" class="hud-bar-fill" style="width: 100%"></div></div>
        </div>
        <div class="hud-row">
             <span class="hud-label" style="font-size:10px; color:#aa8800; margin-top:5px;">RECURSOS (ENERGIA): <span id="hud-energy">80</span>%</span>
        </div>
    </div>

    <div id="message-log"></div>

    <div id="peephole-ui">
        <div id="visitor-visual"></div>
        <div id="dialogue-box"><span id="dialogue-text">...</span></div>
        <div id="door-controls">
            <button class="door-btn btn-interrogate" onclick="window.gameActions.interrogate()">QUEM √â?</button>
            <button class="door-btn btn-open" onclick="window.gameActions.openDoor()">ABRIR</button>
            <button class="door-btn btn-shock" onclick="window.gameActions.shockDoor()">ELETROCUTAR</button>
            <button class="door-btn" onclick="window.gameActions.exitPeephole()">VOLTAR</button>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

    const apiKey = ""; 
    
    // --- VARI√ÅVEIS DE C√ÇMERA (NOVO) ---
    let camPitch = 0;
    let camYaw = 0;
    let targetPitch = 0;
    let targetYaw = 0;
    const LOOK_SPEED = 0.002;
    const SMOOTH_FACTOR = 0.15; 
    const MAX_YAW = Math.PI / 1.5; 
    const MAX_PITCH = Math.PI / 3; 

    // --- NARRATIVAS EXPANDIDAS (AT√â DIA 8) ---
    const NARRATIVE_EVENTS = [
        {
            title: "NOITE 1: O PROTOCOLO DE HERAN√áA",
            body: "Voc√™ encontra um arquivo criptografado no sistema chamado 'Protocolo de Heran√ßa'. Ele detalha que a fam√≠lia no bunker foi selecionada geneticamente para 'repopular' a Terra, mas o custo foi a elimina√ß√£o dos 'imperfeitos' l√° fora. Sua fam√≠lia pergunta o que voc√™ est√° lendo.",
            choices: [
                { text: "Contar a verdade (Aumenta Sanidade, Diminui Humor)", effect: { sanity: 20, family: -20 }, msg: "A verdade d√≥i. Eles olham para voc√™ com medo." },
                { text: "Mentir para proteger (Aumenta Humor, Diminui Sanidade)", effect: { sanity: -10, family: 10 }, msg: "Voc√™ guarda o fardo sozinho. A ignor√¢ncia √© uma b√™n√ß√£o." }
            ]
        },
        {
            title: "NOITE 2: O R√ÅDIO AMADOR",
            body: "Sua filha mais nova consertou um r√°dio velho. Ela diz ter ouvido uma voz chamando por 'Cobaia 7'. Esse era o seu codinome na Iniciativa Pluribus antes da Jun√ß√£o. Ela quer responder.",
            choices: [
                { text: "Permitir contato (Risco Alto)", effect: { energy: -20, door: -20 }, msg: "O sinal atraiu aten√ß√£o indesejada para a porta." },
                { text: "Destruir o r√°dio (Diminui Humor)", effect: { family: -30 }, msg: "Ela chora. O sil√™ncio retorna ao bunker." }
            ]
        },
        {
            title: "NOITE 3: A OFERTA DA CORPORA√á√ÉO",
            body: "Um drone da Lumon-Pluribus paira na ventila√ß√£o. Ele oferece c√°psulas de nutri√ß√£o perfeitas em troca de dados biom√©tricos de um dos membros da fam√≠lia. Algu√©m teria que doar sangue... muito sangue.",
            choices: [
                { text: "Aceitar a troca (Energia M√°xima, Dano Fam√≠lia)", effect: { energy: 100, family: -40 }, msg: "O drone parte com o sangue. A comida tem gosto de culpa." },
                { text: "Recusar e passar fome (Perde Energia)", effect: { energy: -30, sanity: 10 }, msg: "Voc√™s mant√™m a dignidade, mas a fome aperta." }
            ]
        },
        {
            title: "NOITE 4: O PASSADO ESQUECIDO",
            body: "Voc√™ tem um sonho v√≠vido. Antes do bunker, voc√™ n√£o era um civil. Voc√™ era um dos arquitetos da Jun√ß√£o. Voc√™ lembra de ter trancado as portas do lado de fora.",
            choices: [
                { text: "Aceitar seu passado (Perde Sanidade)", effect: { sanity: -30 }, msg: "A culpa √© esmagadora, mas real." },
                { text: "Reprimir a mem√≥ria (Gasta Energia)", effect: { energy: -20 }, msg: "Voc√™ toma p√≠lulas para dormir. O passado morre." }
            ]
        },
        {
            title: "NOITE 5: A FALHA NO FILTRO",
            body: "O sistema de filtragem de ar est√° emitindo um som agudo. O ar est√° ficando pesado. Se n√£o consertarmos, a fam√≠lia vai adoecer, mas sair para consertar o duto externo √© suic√≠dio.",
            choices: [
                { text: "Consertar externamente (Risco de Sa√∫de)", effect: { familyHealth: -20, door: -10 }, msg: "Voc√™ inalou esporos, mas o ar limpou." },
                { text: "Improvisar com pe√ßas da porta (Dano na Porta)", effect: { door: -30 }, msg: "A porta ficou mais fraca, mas respiramos bem." }
            ]
        },
        {
            title: "NOITE 6: O VIZINHO",
            body: "Voc√™ v√™ o Sr. Alencar, seu antigo vizinho, pela c√¢mera. Ele n√£o √© mais humano... ele tem m√∫ltiplos bra√ßos e chora com a voz de uma crian√ßa. Ele est√° arranhando a parede, n√£o a porta.",
            choices: [
                { text: "Atirar para acabar com o sofrimento (Perde Sanidade)", effect: { sanity: -20 }, msg: "O tiro ecoou. O choro parou. O sil√™ncio √© pior." },
                { text: "Ignorar e aumentar o volume da TV (Perde Humor)", effect: { familyMood: -20 }, msg: "Sua fam√≠lia ouviu tudo. Eles sabem que voc√™ o deixou l√°." }
            ]
        },
        {
            title: "NOITE 7: O ULTIMATO",
            body: "A R√°dio Pluribus anuncia a 'Limpeza Final' para o amanhecer. Drones de exterm√≠nio varrer√£o a √°rea. Precisamos de energia para os escudos ou refor√ßar a estrutura f√≠sica.",
            choices: [
                { text: "Sobrecarrregar gerador (Gasta Energia, Aumenta Porta)", effect: { energy: -50, door: 50 }, msg: "As luzes piscam, mas as travas magn√©ticas est√£o no m√°ximo." },
                { text: "Racionar para fuga (Recupera Energia, Perde Porta)", effect: { energy: 30, door: -20 }, msg: "Energia guardada para os exosuites. A porta fica por conta pr√≥pria." }
            ]
        }
        // DIA 8 AGORA √â GERADO DINAMICAMENTE
    ];

    // --- TROF√âUS EXPANDIDOS ---
    const TROPHIES = {
        FIRST_BLOOD: { id: 'first_blood', title: "Primeiro Sangue", desc: "Eletrocutou um visitante.", icon: "‚ö°" },
        SAVIOR: { id: 'savior', title: "O Salvador", desc: "Salvou 3 humanos.", icon: "ü§ù" },
        SLAYER: { id: 'slayer', title: "Exterminador", desc: "Matou 3 monstros.", icon: "üíÄ" },
        SURVIVOR: { id: 'survivor', title: "Meio Caminho", desc: "Chegou ao Dia 4.", icon: "üìÖ" },
        MECHANIC: { id: 'mechanic', title: "Engenheiro", desc: "Reparou a porta ao m√°ximo.", icon: "üîß" },
        FAMILY_FIRST: { id: 'family', title: "Pai de Fam√≠lia", desc: "Manteve o humor da fam√≠lia em 100%.", icon: "‚ù§Ô∏è" },
        LORE_MASTER: { id: 'lore_master', title: "Arquivista", desc: "Coletou 3 arquivos de lore.", icon: "üìÇ" },
        RADIO_OP: { id: 'radio_op', title: "Operador de R√°dio", desc: "Sincronizou 3 sinais.", icon: "üì°" },
        VETERAN: { id: 'veteran', title: "Veterano", desc: "Chegou ao Dia 8.", icon: "üéñÔ∏è" },
        DOCTOR: { id: 'doctor', title: "M√©dico de Campo", desc: "Curou a fam√≠lia 3 vezes.", icon: "üíä" },
        TRUTH_SEEKER: { id: 'truth', title: "Verdade Oculta", desc: "Descobriu a verdade sobre o bunker.", icon: "üëÅÔ∏è" },
        PLATINUM: { id: 'plat', title: "A JUN√á√ÉO PERFEITA", desc: "Coletou todos os trof√©us.", icon: "üèÜ" }
    };

    const LORE_DATABASE = [
        { id: 1, title: "PROTOCOLO 0", text: "A Jun√ß√£o n√£o √© salva√ß√£o. √â um filtro. Apenas o DNA puro deve restar. O bunker √© uma gaiola.", encrypted: false },
        { id: 2, title: "M√çMICOS", text: "Eles n√£o conseguem piscar corretamente. Observe os olhos. Eles repetem a √∫ltima palavra.", encrypted: false },
        { id: 3, title: "FREQU√äNCIA 98.5", text: "Ouve-se m√∫sica cl√°ssica na 98.5. Dizem que acalma os brutamontes. Vale a pena tentar.", encrypted: false },
        { id: 4, title: "BUNKER 7", text: "N√≥s somos o grupo de controle. N√£o h√° resgate vindo. A comida tem sedativos.", encrypted: false },
        { id: 5, title: "CULTISTAS", text: "Eles usam mantos para esconder as muta√ß√µes. N√£o olhe para a luz que eles carregam.", encrypted: false },
        // NOVOS ARQUIVOS CRIPTOGRAFADOS PARA FINAIS
        { id: 6, title: "MAPA DOS T√öNEIS", text: "H√Å UMA SA√çDA DE EMERG√äNCIA NOS DUTOS DO SETOR 4. O RESGATE DA CORPORA√á√ÉO √â UMA ARMADILHA DE LIMPEZA.", encrypted: true, scrambled: "X7A U#A S@!DA D3 EM3RG... [DADOS CORROMPIDOS]" },
        { id: 7, title: "PROJETO G√äNESE", text: "VOC√ä N√ÉO √â UM SOBREVIVENTE. VOC√ä √â O ADMINISTRADOR DE TESTE 09. A FAM√çLIA S√ÉO BIODROIDS DE TESTE DE ESTRESSE.", encrypted: true, scrambled: "V0C# N@0 E U% S0BR3V... [ACESSO NEGADO]" }
    ];

    const VISITOR_TYPES = [
        { 
            id: 'survivor', type: 'good', name: 'Sobrevivente', visual: `___\n(o o)\n| - |\n-----`, 
            prompt: "Humano desesperado. Fale 10 palavras pedindo abrigo.", reward: { energy: 10, sanity: 5 }, 
            desc: "Apenas algu√©m tentando viver.",
            lines: ["Por favor, abram! Eles est√£o vindo!", "Tenho comida... troco por abrigo.", "N√£o sou um deles, juro!", "Minha perna est√° sangrando..."]
        },
        { 
            id: 'medic', type: 'good', name: 'M√©dico', visual: `___\n(o o)\n| + |\n-----`, 
            prompt: "M√©dico militar calmo.", reward: { energy: 10, sanity: 30 }, 
            desc: "Traz rem√©dios.",
            lines: ["Sou m√©dico da Divis√£o 4. Tenho penicilina.", "Posso tratar seus feridos.", "Preciso de um local seguro para operar.", "A infec√ß√£o est√° se espalhando l√° fora."]
        },
        { 
            id: 'mechanic', type: 'good', name: 'Mec√¢nico', visual: `___\n[o o]\n| # |\n-----`, 
            prompt: "Mec√¢nico pr√°tico.", reward: { energy: 10, door: 40 }, 
            desc: "Pode reparar a porta.",
            lines: ["Essa porta vai ceder logo. Posso consertar.", "Tenho ferramentas e sucata.", "O filtro de ar de voc√™s est√° falhando.", "Engenheiro N√≠vel 3 solicitando acesso."]
        },
        { 
            id: 'mimic', type: 'bad', name: 'M√≠mico', visual: `___\n(o o)\n| O |\n-----`, 
            prompt: "Monstro M√≠mico. Tente falar como humano, mas falhe.", damage: { door: 30, sanity: 30 }, 
            desc: "Finge ser gente.",
            lines: ["Abra... a... porta... amigos.", "Eu sou... humano... como... voc√™s...", "Carne... fresca... digo... abrigo.", "M√£e? Pai? Sou eu..."]
        },
        { 
            id: 'brute', type: 'bad', name: 'Brutamontes', visual: `/ \\\n(X X)\n(###)\n\\___/`, 
            prompt: "Monstro violento.", damage: { door: 60, sanity: 10 }, 
            desc: "Dano massivo na porta.",
            lines: ["GRRAAAAAH!", "ESMAGAR!", "FOME!", "(Sons de metal sendo amassado)"]
        },
        { 
            id: 'cultist', type: 'bad', name: 'Cultista', visual: ` / \\\n(o o)\n |^| \n-----`, 
            prompt: "Fan√°tico religioso.", damage: { door: 10, sanity: 50 }, 
            desc: "Drena sua sanidade.",
            lines: ["A Jun√ß√£o nos far√° um s√≥.", "Abram para a gl√≥ria do Novo Amanhecer.", "Seus genes s√£o impuros.", "O sil√™ncio √© a √∫nica salva√ß√£o."]
        }
    ];

    const STATE = {
        playing: false,
        day: 1,
        maxDays: 8,
        dayTime: 300,
        
        sanity: 80,
        energy: 80,
        doorHealth: 100,
        familyMood: 100,
        familyHealth: 100, 
        
        dailySurvivorsLetIn: 0,
        survivorsQuota: 2,
        
        // CONTROLE DE VISITA E REVIVAL
        nextVisitorTimer: 60,
        revivalUsed: false,
        revivalReason: '',
        
        doorKnocking: false,
        visitor: null,
        lookingAtPeephole: false,
        screenView: 'BOOT', 
        currentLocation: 'BUNKER',
        gameOver: false,
        interrogated: false,
        isNarrativeMode: false,
        
        // LORE & RADIO PUZZLE
        unlockedLore: [], // Lista de IDs desbloqueados
        decodedLore: [], // Lista de IDs decodificados
        radio: { 
            target: { freq: 5, amp: 50 }, 
            current: { freq: 2, amp: 20 }, 
            locked: false 
        },
        
        stats: { 
            humansSaved: 0, 
            monstersKilled: 0, 
            unlockedTrophies: [],
            radioSignals: 0,
            familyHeals: 0
        },
        quiz: { question: "", options: [], answer: 0, rewardType: '', rewardAmount: 0 },
        
        // MINIGAMES STATE
        minigame: {
            active: null, // 'SNAKE', 'MEMORY', 'PACMAN'
            isRevival: false, // FLAG DE REVIVAL
            snake: { snake: [{x:10, y:10}], dir: {x:0, y:0}, food: {x:15, y:15}, score: 0, speed: 10, tick: 0 },
            memory: { cards: [], flipped: [], matches: 0, locked: false, grid: [4, 3] },
            pacman: { 
                player: {x:1, y:1}, 
                ghost: {x:7, y:7, tick: 0, speed: 16}, 
                score: 0, 
                map: [], 
                width: 15, 
                height: 15 
            }
        }
    };

    const LOCATIONS = {
        BUNKER: { color: 0xffcc00, fog: 0x050505, fogDens: 0.15 },
        MARKET: { color: 0x00FFFF, fog: 0x001133, fogDens: 0.3 },
        PHARMACY: { color: 0xFFFFFF, fog: 0xEEEEEE, fogDens: 0.4 },
        STREETS: { color: 0xFF6600, fog: 0x331100, fogDens: 0.6 }
    };
    const QUIZ_DATA = {
        MARKET: [
            { q: "Lata sem r√≥tulo.", opt: ["Comer", "Ignorar", "Guardar"], ans: 1, type: 'energy', val: 20, fail: -10 },
            { q: "Pessoa presa.", opt: ["Soltar", "Roubar", "Matar"], ans: 0, type: 'survivor', val: 1, fail: -20 },
            { q: "Terminal de dados.", opt: ["Hackear", "Destruir", "Ignorar"], ans: 0, type: 'lore', val: 1, fail: -20 } // Chance de Lore Criptografada
        ],
        PHARMACY: [
            { q: "Soro experimental.", opt: ["Usar", "Estocar", "Destruir"], ans: 1, type: 'sanity', val: 30, fail: -20 },
            { q: "Gritos no fundo.", opt: ["Investigar", "Fugir", "Chamar"], ans: 1, type: 'sanity', val: 10, fail: -30 },
            { q: "Pasta confidencial.", opt: ["Ler", "Queimar", "Levar"], ans: 2, type: 'lore', val: 1, fail: -10 }
        ],
        STREETS: [
            { q: "N√©voa √°cida.", opt: ["Correr", "Sinalizador", "Abrigo"], ans: 2, type: 'sanity', val: 20, fail: -40 },
            { q: "Crian√ßa sozinha.", opt: ["Resgatar", "Observar", "Ignorar"], ans: 0, type: 'survivor', val: 1, fail: -20 },
            { q: "Drone ca√≠do.", opt: ["Sucatear", "Analisar Dados", "Chutar"], ans: 1, type: 'lore', val: 1, fail: -10 }
        ]
    };

    window.gameActions = {
        interrogate: () => interrogateVisitor(),
        openDoor: () => resolveDoor(true),
        shockDoor: () => resolveDoor(false),
        exitPeephole: () => exitPeepholeMode()
    };

    let camera, scene, renderer;
    let monitorTexture, monitorContext, monitorMesh;
    let pointLightPC, pointLightEmergency;
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();
    let audioCtx, masterGain;

    // --- INPUTS ---
    function onMouseMove(e) {
        if (!STATE.playing || STATE.gameOver || STATE.lookingAtPeephole || STATE.isNarrativeMode) return;
        // Se for minigame de revival, bloqueia movimento da c√¢mera
        if (STATE.screenView.startsWith('GAME_') && STATE.minigame.isRevival) return;
        
        targetYaw -= e.movementX * LOOK_SPEED;
        targetPitch -= e.movementY * LOOK_SPEED;
        targetPitch = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, targetPitch));
        targetYaw = Math.max(-MAX_YAW, Math.min(MAX_YAW, targetYaw));
    }
    
    // CONTROLE DOS MINIGAMES E R√ÅDIO
    document.addEventListener('keydown', (e) => {
        if (!STATE.playing) return;
        
        const key = e.key.toLowerCase();
        
        // RADIO PUZZLE CONTROL
        if (STATE.screenView === 'RADIO') {
            if (key === 'arrowleft' || key === 'a') STATE.radio.current.freq = Math.max(1, STATE.radio.current.freq - 0.2);
            if (key === 'arrowright' || key === 'd') STATE.radio.current.freq = Math.min(15, STATE.radio.current.freq + 0.2);
            if (key === 'arrowdown' || key === 's') STATE.radio.current.amp = Math.max(10, STATE.radio.current.amp - 2);
            if (key === 'arrowup' || key === 'w') STATE.radio.current.amp = Math.min(100, STATE.radio.current.amp + 2);
            return;
        }

        if (STATE.screenView.startsWith('GAME_') === false) return;
        
        // Snake Controls
        if (STATE.screenView === 'GAME_SNAKE') {
            const s = STATE.minigame.snake;
            if ((key === 'arrowup' || key === 'w') && s.dir.y === 0) s.dir = {x:0, y:-1};
            if ((key === 'arrowdown' || key === 's') && s.dir.y === 0) s.dir = {x:0, y:1};
            if ((key === 'arrowleft' || key === 'a') && s.dir.x === 0) s.dir = {x:-1, y:0};
            if ((key === 'arrowright' || key === 'd') && s.dir.x === 0) s.dir = {x:1, y:0};
        }
        
        // Pacman Controls
        if (STATE.screenView === 'GAME_PACMAN') {
            const p = STATE.minigame.pacman;
            let dx = 0, dy = 0;
            if (key === 'arrowup' || key === 'w') dy = -1;
            if (key === 'arrowdown' || key === 's') dy = 1;
            if (key === 'arrowleft' || key === 'a') dx = -1;
            if (key === 'arrowright' || key === 'd') dx = 1;
            
            if (dx !== 0 || dy !== 0) {
                const nx = p.player.x + dx;
                const ny = p.player.y + dy;
                if (p.map[ny] && p.map[ny][nx] !== 1) {
                    p.player.x = nx;
                    p.player.y = ny;
                    if (p.map[ny][nx] === 2) { // Eat dot
                        p.map[ny][nx] = 0;
                        p.score++;
                        playSound('click');
                        if (checkPacmanWin()) {
                            if (STATE.minigame.isRevival) revivePlayer();
                            else winMinigame();
                        }
                    }
                }
            }
        }
    });

    function updateCameraSmooth() {
        if (!STATE.playing || STATE.gameOver || STATE.lookingAtPeephole) return;
        if (STATE.minigame.isRevival) {
            camera.lookAt(0, 1.2, 0.31); 
            return;
        }
        camPitch += (targetPitch - camPitch) * SMOOTH_FACTOR;
        camYaw += (targetYaw - camYaw) * SMOOTH_FACTOR;
        camera.rotation.set(camPitch, camYaw, 0, 'YXZ');
    }

    function updateTimer(dt) {
        if (STATE.gameOver || STATE.isNarrativeMode || STATE.screenView === 'LOCATION_QUIZ' || STATE.screenView.startsWith('GAME_')) return;
        
        const TIME_SCALE = 2.5; 
        const gameDt = dt * TIME_SCALE;
        
        STATE.dayTime -= gameDt;
        
        if (STATE.currentLocation === 'BUNKER' && !STATE.doorKnocking && !STATE.isNarrativeMode) {
            STATE.nextVisitorTimer -= gameDt;
            if (STATE.nextVisitorTimer <= 0) {
                triggerKnockEvent();
                STATE.nextVisitorTimer = 60; 
            }
        }

        if (STATE.doorKnocking) {
            const decay = 2.0 * dt; 
            STATE.doorHealth -= decay;
            if (STATE.doorHealth <= 0) checkState();
        }

        if (STATE.dayTime <= 0) {
            STATE.dayTime = 0;
            triggerEndOfDay();
        }
        
        const min = Math.floor(STATE.dayTime / 60);
        const sec = Math.floor(STATE.dayTime % 60);
        document.getElementById('timer-display').innerText = `${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
        
        if(STATE.doorKnocking) updateHUD();
    }

    function triggerEndOfDay() {
        STATE.radio.target = (Math.random() * (107.0 - 89.0) + 89.0);
        STATE.radio.locked = false;

        if (STATE.dailySurvivorsLetIn < STATE.survivorsQuota) {
            triggerGameOver(`COTA N√ÉO ATINGIDA (${STATE.dailySurvivorsLetIn}/${STATE.survivorsQuota}). O Comando Central isolou seu bunker.`);
            return;
        }
        
        // --- LOGICA DE FINAL M√öLTIPLO NO DIA 8 ---
        if (STATE.day >= 8) {
            STATE.isNarrativeMode = true;
            document.exitPointerLock();
            
            const overlay = document.getElementById('narrative-overlay');
            const title = document.getElementById('narrative-title');
            const body = document.getElementById('narrative-body');
            const choicesDiv = document.getElementById('narrative-choices');
            const consq = document.getElementById('consequence-text');
            
            title.innerText = "DIA 8: A HORA DA VERDADE";
            body.innerText = "O prazo acabou. O 'Resgate' est√° aqui. Drones de transporte cercam o bunker. Mas o sil√™ncio √© perturbador.";
            consq.style.opacity = 0;
            choicesDiv.innerHTML = '';

            // FINAL A: PADR√ÉO (RESGATE)
            const btnA = document.createElement('button');
            btnA.className = 'choice-btn';
            btnA.innerText = "Aceitar Resgate (Final Padr√£o)";
            btnA.onclick = () => triggerEnding("RESGATE", "Voc√™ e sua fam√≠lia embarcaram nas naves da Pluribus. Dizem que o novo mundo √© seguro... mas por que todos usam m√°scaras?");
            choicesDiv.appendChild(btnA);

            // FINAL B: FUGA (REQUER MAPA DOS T√öNEIS DECODIFICADO)
            if (STATE.decodedLore.includes(6)) {
                const btnB = document.createElement('button');
                btnB.className = 'choice-btn';
                btnB.innerText = "Fugir pelos T√∫neis (A Verdade)";
                btnB.style.borderColor = "#00ffaa";
                btnB.style.color = "#00ffaa";
                btnB.onclick = () => { unlockTrophy('TRUTH_SEEKER'); triggerEnding("FUGA", "Voc√™ sabia que o resgate era uma armadilha. O mapa levou voc√™s para longe da cidade. A liberdade √© fria e perigosa, mas √© real."); };
                choicesDiv.appendChild(btnB);
            }

            // FINAL C: O ARQUITETO (REQUER PROJETO G√äNESE + SANIDADE ALTA)
            if (STATE.decodedLore.includes(7) && STATE.sanity > 80) {
                const btnC = document.createElement('button');
                btnC.className = 'choice-btn';
                btnC.innerText = "Reiniciar Simula√ß√£o (O Arquiteto)";
                btnC.style.borderColor = "#ff00ff";
                btnC.style.color = "#ff00ff";
                btnC.onclick = () => triggerEnding("ARQUITETO", "Voc√™ acessou o terminal mestre. 'Encerrar Itera√ß√£o 404'. O mundo l√° fora sumiu. Voc√™ acorda em um laborat√≥rio limpo. 'Teste conclu√≠do com sucesso, Administrador'.");
                choicesDiv.appendChild(btnC);
            }

            // FINAL D: ASSIMILA√á√ÉO (SANIDADE BAIXA)
            if (STATE.sanity < 20) {
                const btnD = document.createElement('button');
                btnD.className = 'choice-btn';
                btnD.innerText = "Aceitar a Jun√ß√£o (Render-se)";
                btnD.style.borderColor = "#ff0000";
                btnD.style.color = "#ff0000";
                btnD.onclick = () => triggerEnding("ASSIMILA√á√ÉO", "Por que lutar? A voz deles √© t√£o doce. Voc√™ abre a porta e deixa a luz entrar. N√£o h√° mais dor. Somos todos um agora.");
                choicesDiv.appendChild(btnD);
            }

            overlay.style.display = 'flex';
            playSound('travel');
            return;
        }

        STATE.isNarrativeMode = true;
        document.exitPointerLock();
        const eventIdx = Math.min(STATE.day - 1, NARRATIVE_EVENTS.length - 1);
        const event = NARRATIVE_EVENTS[eventIdx] || NARRATIVE_EVENTS[NARRATIVE_EVENTS.length-1];
        const overlay = document.getElementById('narrative-overlay');
        const title = document.getElementById('narrative-title');
        const body = document.getElementById('narrative-body');
        const choicesDiv = document.getElementById('narrative-choices');
        const consq = document.getElementById('consequence-text');
        title.innerText = event.title;
        body.innerText = event.body;
        consq.style.opacity = 0;
        choicesDiv.innerHTML = '';
        event.choices.forEach(choice => {
            const btn = document.createElement('button');
            btn.className = 'choice-btn';
            btn.innerText = choice.text;
            btn.onclick = () => resolveNarrative(choice);
            choicesDiv.appendChild(btn);
        });
        overlay.style.display = 'flex';
        playSound('travel');
    }

    function triggerEnding(type, msg) {
        unlockTrophy('VETERAN');
        document.body.innerHTML = `
            <div style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;background:black;color:#ffcc00;font-family:monospace;padding:40px;text-align:center;">
                <h1 style="font-size:40px;margin-bottom:20px;">FINAL: ${type}</h1>
                <p style="font-size:20px;line-height:1.6;max-width:800px;">${msg}</p>
                <br><br>
                <button style="background:transparent;border:2px solid #ffcc00;color:#ffcc00;padding:15px 30px;font-family:monospace;cursor:pointer;" onclick="location.reload()">REINICIAR SISTEMA</button>
            </div>
        `;
    }

    function resolveNarrative(choice) {
        if (choice.effect.sanity) STATE.sanity += choice.effect.sanity;
        if (choice.effect.energy) STATE.energy += choice.effect.energy;
        if (choice.effect.family) STATE.familyMood += choice.effect.family;
        if (choice.effect.door) STATE.doorHealth += choice.effect.door;
        if (choice.effect.familyHealth) STATE.familyHealth += choice.effect.familyHealth;

        STATE.sanity = Math.min(100, Math.max(0, STATE.sanity));
        STATE.energy = Math.min(100, Math.max(0, STATE.energy));
        STATE.familyMood = Math.min(100, Math.max(0, STATE.familyMood));
        STATE.doorHealth = Math.min(100, Math.max(0, STATE.doorHealth));
        STATE.familyHealth = Math.min(100, Math.max(0, STATE.familyHealth));

        const consq = document.getElementById('consequence-text');
        consq.innerText = choice.msg || "Sua fam√≠lia vai se lembrar disso.";
        consq.style.opacity = 1;
        document.getElementById('narrative-choices').innerHTML = '<button class="choice-btn" id="next-day-btn">INICIAR PR√ìXIMO DIA</button>';
        document.getElementById('next-day-btn').onclick = startNextDay;
    }

    function startNextDay() {
        document.getElementById('narrative-overlay').style.display = 'none';
        document.body.requestPointerLock();
        STATE.day++;
        STATE.dayTime = 300;
        STATE.isNarrativeMode = false;
        STATE.dailySurvivorsLetIn = 0;
        STATE.survivorsQuota = Math.random() < 0.5 ? 1 : 2;
        STATE.familyMood -= 10;
        STATE.energy -= 10;
        STATE.familyHealth -= 5; 
        if(Math.random() < 0.2) {
            STATE.familyHealth -= 15; 
            logMessage("ALERTA: Membro da fam√≠lia adoeceu durante a noite.");
        }
        checkState();
        if (!STATE.gameOver) {
            logMessage(`DIA ${STATE.day} INICIADO. COTA: 0/${STATE.survivorsQuota}`);
        }
    }

    function unlockTrophy(key) {
        if (!TROPHIES[key]) return;
        const trophyId = TROPHIES[key].id;
        if (STATE.stats.unlockedTrophies.includes(trophyId)) return;
        STATE.stats.unlockedTrophies.push(trophyId);
        const popup = document.getElementById('trophy-popup');
        document.getElementById('trophy-icon').innerText = TROPHIES[key].icon;
        document.getElementById('trophy-name').innerText = TROPHIES[key].title;
        popup.style.top = '20px'; setTimeout(() => popup.style.top = '-100px', 4000);
        playSound('trophy');
        if (STATE.stats.unlockedTrophies.length === Object.keys(TROPHIES).length - 1 && !STATE.stats.unlockedTrophies.includes('plat')) setTimeout(() => unlockTrophy('PLATINUM'), 2000);
    }

    function updateHUD() {
        if (!STATE.playing) return;
        document.getElementById('hud-day').innerText = `${STATE.day}/${STATE.maxDays}`;
        document.getElementById('hud-quota').innerText = `${STATE.dailySurvivorsLetIn}/${STATE.survivorsQuota}`;
        document.getElementById('hud-energy').innerText = Math.floor(STATE.energy);
        updateBar('bar-sanity', STATE.sanity, 'row-sanity');
        updateBar('bar-door', STATE.doorHealth, 'row-door');
        updateBar('bar-family', STATE.familyMood, 'row-family'); 
        if (STATE.day >= 8) unlockTrophy('VETERAN');
        if (STATE.familyMood >= 100) unlockTrophy('FAMILY_FIRST');
        if (STATE.unlockedLore.length >= 3) unlockTrophy('LORE_MASTER');
        if (STATE.stats.radioSignals >= 3) unlockTrophy('RADIO_OP');
        if (STATE.stats.familyHeals >= 3) unlockTrophy('DOCTOR');
    }

    function updateBar(id, val, rowId) {
        document.getElementById(id).style.width = `${Math.max(0, Math.min(100, val))}%`;
        document.getElementById(rowId).classList.toggle('danger', val <= 30);
    }

    async function generateVisitorDialogue(visitor) {
        const txt = document.getElementById('dialogue-text');
        document.getElementById('dialogue-box').style.display = 'block';
        txt.innerText = "Analisando...";
        if (!apiKey || apiKey === "") {
            const lines = visitor.lines || [visitor.desc];
            const line = lines[Math.floor(Math.random() * lines.length)];
            setTimeout(() => { typeWriterEffect(`"${line}"\n\n(AN√ÅLISE: ${visitor.name}. ${visitor.desc})`, txt); }, 500);
            return;
        }
        try {
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: visitor.prompt + " Max 12 palavras." }] }], generationConfig: { maxOutputTokens: 50 } })
            });
            const data = await res.json();
            const aiText = data.candidates[0].content.parts[0].text;
            typeWriterEffect(aiText, txt);
        } catch (e) { 
            const lines = visitor.lines || [visitor.desc];
            const line = lines[Math.floor(Math.random() * lines.length)];
            typeWriterEffect(`"${line}"`, txt);
        }
    }

    function typeWriterEffect(text, el) {
        el.innerText = ""; let i = 0;
        function type() { if (i < text.length) { el.innerText += text.charAt(i); i++; setTimeout(type, 15); } }
        type();
    }

    function initAudio() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext(); masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.4; masterGain.connect(audioCtx.destination);
    }

    function playSound(type, pos) {
        if (!audioCtx || STATE.gameOver) return;
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        if (pos) {
            const p = audioCtx.createPanner(); p.panningModel = 'HRTF';
            p.positionX.value = pos.x; p.positionY.value = pos.y; p.positionZ.value = pos.z;
            osc.connect(gain).connect(p).connect(masterGain);
        } else osc.connect(gain).connect(masterGain);
        const now = audioCtx.currentTime;
        if (type === 'click') { osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now+0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now+0.1); osc.start(now); osc.stop(now+0.1); }
        else if (type === 'trophy') { osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+1); osc.start(now); osc.stop(now+1); }
        else if (type === 'travel') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now+2); gain.gain.value = 0.1; osc.start(now); osc.stop(now+2); }
        else if (type === 'hum') { osc.type = 'sine'; osc.frequency.value = 60; gain.gain.value = 0.05; osc.start(now); }
        else if (type === 'knock') { osc.type = 'triangle'; osc.frequency.setValueAtTime(60, now); osc.frequency.exponentialRampToValueAtTime(10, now+0.2); gain.gain.setValueAtTime(1, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.3); osc.start(now); osc.stop(now+0.3); }
        else if (type === 'shock') { osc.type = 'sawtooth'; osc.frequency.linearRampToValueAtTime(1000, now+0.5); gain.gain.setValueAtTime(0.5, now); osc.start(now); osc.stop(now+0.5); }
        else if (type === 'jumpscare') { osc.type = 'sawtooth'; osc.frequency.value = 50; gain.gain.value = 1; osc.start(now); osc.stop(now+2); }
    }

    function updateEnvironment3D() {
        const t = LOCATIONS[STATE.currentLocation];
        pointLightPC.color.lerp(new THREE.Color(t.color), 0.05);
        scene.fog.color.lerp(new THREE.Color(t.fog), 0.05);
        scene.fog.density = THREE.MathUtils.lerp(scene.fog.density, t.fogDens, 0.02);
    }

    const CANVAS_W = 512, CANVAS_H = 512, CRT_COLOR = '#ffcc00';
    let osButtons = [];

    function initMonitorOS() {
        const c = document.createElement('canvas'); c.width = CANVAS_W; c.height = CANVAS_H;
        monitorContext = c.getContext('2d');
        monitorTexture = new THREE.CanvasTexture(c);
        monitorTexture.minFilter = THREE.LinearFilter; monitorTexture.magFilter = THREE.NearestFilter;
    }

    function drawButton(ctx, x, y, w, h, text) {
        ctx.strokeStyle = CRT_COLOR; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
        ctx.fillStyle = CRT_COLOR; ctx.font = '18px monospace'; ctx.fillText(text, x + 10, y + 25);
        return { x, y, w, h };
    }

    function initRadio() {
        STATE.screenView = 'RADIO';
        STATE.radio.target.freq = 2 + Math.random() * 10; 
        STATE.radio.target.amp = 20 + Math.random() * 60; 
        STATE.radio.current.freq = 5;
        STATE.radio.current.amp = 50;
        STATE.radio.locked = false;
    }

    function drawOS() {
        const ctx = monitorContext; if (!ctx) return;
        ctx.fillStyle = '#110d00'; ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
        ctx.shadowBlur = 4; ctx.shadowColor = CRT_COLOR; ctx.fillStyle = CRT_COLOR;
        osButtons = [];

        if (STATE.screenView === 'GAME_SNAKE') updateAndDrawSnake(ctx);
        else if (STATE.screenView === 'GAME_MEMORY') drawMemory(ctx);
        else if (STATE.screenView === 'GAME_PACMAN') updateAndDrawPacman(ctx);
        else if (STATE.screenView === 'RADIO') drawRadio(ctx);
        else if (STATE.screenView === 'ARCHIVES') drawArchives(ctx);
        else if (STATE.screenView === 'DECODER') drawDecoder(ctx); // NOVA TELA

        else if (STATE.screenView === 'DESKTOP') {
            ctx.font = '28px monospace'; ctx.fillText(`PLURIBUS OS v9.0`, 40, 50);
            if (STATE.doorKnocking) { ctx.fillStyle = 'red'; ctx.shadowColor = 'red'; ctx.fillText("ALERTA DE SEGURAN√áA", 120, 450); ctx.fillStyle = CRT_COLOR; ctx.shadowColor = CRT_COLOR; }
            
            osButtons.push({ action: 'GO_MAP', ...drawButton(ctx, 40, 100, 430, 50, "EXPEDI√á√ÉO") });
            osButtons.push({ action: 'GO_FAMILY', ...drawButton(ctx, 40, 170, 200, 50, "FAM√çLIA") });
            osButtons.push({ action: 'GO_ARCHIVES', ...drawButton(ctx, 270, 170, 200, 50, "ARQUIVOS") });
            
            osButtons.push({ action: 'GO_REPAIR', ...drawButton(ctx, 40, 240, 200, 50, "MANUTEN√á√ÉO") });
            osButtons.push({ action: 'GO_RADIO', ...drawButton(ctx, 270, 240, 200, 50, "R√ÅDIO") });
            
            osButtons.push({ action: 'GO_GAMES', ...drawButton(ctx, 40, 310, 200, 50, "JOGOS") }); 
            osButtons.push({ action: 'GO_TROPHIES', ...drawButton(ctx, 270, 310, 200, 50, "TROF√âUS") });
            osButtons.push({ action: 'GO_DECODER', ...drawButton(ctx, 40, 380, 200, 50, "DECODER") }); // Novo Bot√£o
            osButtons.push({ action: 'MAIL', ...drawButton(ctx, 270, 380, 200, 50, "DI√ÅRIO") });
        }
        else if (STATE.screenView === 'GAMES_MENU') {
            ctx.fillText("JOGOS - RECUPERAR SANIDADE", 40, 50);
            osButtons.push({ action: 'START_SNAKE', ...drawButton(ctx, 40, 100, 430, 50, "COBRINHA") });
            osButtons.push({ action: 'START_MEMORY', ...drawButton(ctx, 40, 170, 430, 50, "MEM√ìRIA") });
            osButtons.push({ action: 'START_PACMAN', ...drawButton(ctx, 40, 240, 430, 50, "LABIRINTO") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'TROPHIES') {
            ctx.fillText("COLE√á√ÉO DE TROF√âUS", 40, 50); let y = 100;
            Object.values(TROPHIES).forEach(t => {
                const un = STATE.stats.unlockedTrophies.includes(t.id);
                ctx.fillStyle = un ? CRT_COLOR : '#554400'; ctx.fillText(`${un ? `[X] ${t.icon}` : `[ ] üîí`} ${t.title}`, 40, y); y += 30;
            });
            ctx.fillStyle = CRT_COLOR; osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'FAMILY') {
            ctx.fillText("STATUS DA FAM√çLIA", 40, 50);
            ctx.fillStyle = STATE.familyMood < 30 ? '#ff3333' : CRT_COLOR;
            ctx.fillText(`HUMOR: ${Math.floor(STATE.familyMood)}%`, 40, 90);
            ctx.fillStyle = STATE.familyHealth < 30 ? '#ff3333' : CRT_COLOR;
            ctx.fillText(`SA√öDE: ${Math.floor(STATE.familyHealth)}%`, 240, 90);
            osButtons.push({ action: 'FAM_FEED', ...drawButton(ctx, 40, 130, 430, 40, "DAR RA√á√ÉO (20 EN)") });
            osButtons.push({ action: 'FAM_TALK', ...drawButton(ctx, 40, 180, 430, 40, "CONVERSAR (10 EN)") });
            osButtons.push({ action: 'FAM_MEDIC', ...drawButton(ctx, 40, 230, 430, 40, "MEDICAR (30 EN)") }); 
            osButtons.push({ action: 'FAM_PLAY', ...drawButton(ctx, 40, 280, 430, 40, "JOGAR JUNTOS (15 EN)") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 350, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'REPAIR') {
            ctx.fillText("MANUTEN√á√ÉO", 40, 50);
            ctx.fillText(`INTEGRIDADE: ${STATE.doorHealth.toFixed(1)}%`, 40, 90);
            osButtons.push({ action: 'REP_DOOR', ...drawButton(ctx, 40, 200, 430, 50, "REPARAR (30 EN)") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }
        else if (STATE.screenView === 'MAP') {
            ctx.fillText("DESTINO DA EXPEDI√á√ÉO:", 40, 50);
            osButtons.push({ action: 'GO_MARKET', ...drawButton(ctx, 40, 100, 430, 50, "MERCADO") });
            osButtons.push({ action: 'GO_PHARMA', ...drawButton(ctx, 40, 170, 430, 50, "FARM√ÅCIA") });
            osButtons.push({ action: 'GO_STREET', ...drawButton(ctx, 40, 240, 430, 50, "RUAS") });
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 400, 100, 40, "CANCELAR") });
        }
        else if (STATE.screenView === 'LOCATION_QUIZ') {
            ctx.fillText(`LOCAL: ${STATE.currentLocation}`, 40, 40);
            const w = STATE.quiz.question.split(' '); let l = '', y = 80;
            w.forEach(word => { if (ctx.measureText(l + word).width > 450) { ctx.fillText(l, 40, y); l = word + ' '; y += 25; } else l += word + ' '; });
            ctx.fillText(l, 40, y);
            STATE.quiz.options.forEach((opt, i) => osButtons.push({ action: `ANS_${i}`, ...drawButton(ctx, 40, 200 + (i * 70), 430, 50, `${i+1}. ${opt}`) }));
        }
        else if (STATE.screenView === 'RESULT') {
            ctx.fillText("RESULTADO:", 40, 100); ctx.fillText(STATE.quiz.resultMsg, 40, 150);
        }
        else if (STATE.screenView === 'BOOT') {
            ctx.fillText("INICIALIZANDO...", 40, 100); if (Math.random() > 0.9) STATE.screenView = 'DESKTOP';
        }
        else if (STATE.screenView === 'MAIL') {
            ctx.fillText("DI√ÅRIO:", 40, 50);
            ctx.fillText("- M√≠micos podem parecer humanos.", 40, 100);
            osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
        }

        ctx.fillStyle = "rgba(255, 200, 0, 0.1)"; for (let i = 0; i < CANVAS_H; i += 4) ctx.fillRect(0, i, CANVAS_W, 2);
        monitorTexture.needsUpdate = true;
    }
    
    // --- RADIO PUZZLE SCREEN ---
    function drawRadio(ctx) {
        ctx.fillText("SINTONIZADOR DE ONDAS CURTAS", 40, 30);
        ctx.font = '14px monospace';
        ctx.fillText("Use SETAS para alinhar as ondas.", 40, 50);
        ctx.fillText("ESQ/DIR: Frequ√™ncia | CIMA/BAIXO: Amplitude", 40, 70);
        ctx.fillStyle = '#001100';
        ctx.fillRect(40, 100, 430, 200);
        ctx.strokeStyle = '#004400';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=40; i<470; i+=20) { ctx.moveTo(i, 100); ctx.lineTo(i, 300); }
        for(let i=100; i<300; i+=20) { ctx.moveTo(40, i); ctx.lineTo(470, i); }
        ctx.stroke();
        function drawWave(freq, amp, color, opacity) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = opacity;
            for (let x = 0; x < 430; x++) {
                const y = amp * Math.sin((x * freq * 0.05) + (Date.now() * 0.005));
                if (x === 0) ctx.moveTo(40 + x, 200 + y);
                else ctx.lineTo(40 + x, 200 + y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
        drawWave(STATE.radio.target.freq, STATE.radio.target.amp, '#ff3333', 0.5);
        drawWave(STATE.radio.current.freq, STATE.radio.current.amp, '#00ff00', 1.0);
        const diffFreq = Math.abs(STATE.radio.target.freq - STATE.radio.current.freq);
        const diffAmp = Math.abs(STATE.radio.target.amp - STATE.radio.current.amp);
        const matchQuality = 100 - (diffFreq * 10 + diffAmp * 0.5);
        const isMatched = diffFreq < 0.5 && diffAmp < 5;
        ctx.font = '18px monospace';
        ctx.fillStyle = CRT_COLOR;
        ctx.fillText(`SINCRONIA: ${Math.max(0, Math.floor(matchQuality))}%`, 40, 330);
        if (isMatched && !STATE.radio.locked) {
            STATE.radio.locked = true;
            playSound('click');
            STATE.sanity = Math.min(100, STATE.sanity + 20);
            STATE.stats.radioSignals++;
            logMessage("SINAL DECODIFICADO. SANIDADE +20.");
        }
        if (STATE.radio.locked) {
            ctx.fillStyle = '#00ff00';
            ctx.fillText("CONEX√ÉO ESTABELECIDA.", 250, 330);
            osButtons.push({ action: 'RADIO_LURE', ...drawButton(ctx, 40, 350, 430, 40, "EMITIR SINAL DE RESGATE (40 EN)") });
        }
        osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
    }

    // --- ARCHIVES SCREEN ---
    function drawArchives(ctx) {
        ctx.fillText("ARQUIVOS RECUPERADOS", 40, 50);
        let y = 100;
        if (STATE.unlockedLore.length === 0) {
            ctx.fillStyle = '#554400';
            ctx.fillText("NENHUM DADO ENCONTRADO.", 40, 100);
        } else {
            STATE.unlockedLore.forEach(id => {
                const log = LORE_DATABASE.find(l => l.id === id);
                if (log) {
                    ctx.fillStyle = CRT_COLOR;
                    const isDecoded = STATE.decodedLore.includes(id);
                    const displayText = (log.encrypted && !isDecoded) ? log.scrambled : log.text;
                    const title = (log.encrypted && !isDecoded) ? "DADOS CORROMPIDOS" : log.title;
                    const color = (log.encrypted && !isDecoded) ? "#ff3333" : CRT_COLOR;
                    
                    ctx.fillStyle = color;
                    ctx.fillText(`[${title}]`, 40, y);
                    ctx.font = '14px monospace';
                    ctx.fillText(displayText, 40, y + 20);
                    ctx.font = '18px monospace';
                    y += 60;
                }
            });
        }
        osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
    }

    // --- DECODER SCREEN (NEW) ---
    function drawDecoder(ctx) {
        ctx.fillText("DECODIFICADOR DE DADOS", 40, 50);
        
        // Find locked encrypted files
        const encryptedFiles = LORE_DATABASE.filter(l => STATE.unlockedLore.includes(l.id) && l.encrypted && !STATE.decodedLore.includes(l.id));
        
        let y = 100;
        if (encryptedFiles.length === 0) {
            ctx.fillText("NENHUM ARQUIVO CRIPTOGRAFADO.", 40, 100);
        } else {
            encryptedFiles.forEach(file => {
                ctx.fillStyle = '#ff3333';
                ctx.fillText(`ARQUIVO: ID-${file.id}`, 40, y + 25);
                osButtons.push({ action: `DECRYPT_${file.id}`, ...drawButton(ctx, 250, y, 220, 40, "DECODIFICAR (20 SAN)") });
                y += 60;
            });
        }
        osButtons.push({ action: 'BACK', ...drawButton(ctx, 40, 420, 100, 40, "VOLTAR") });
    }
    
    function handleDecrypt(id) {
        if (STATE.sanity >= 20) {
            STATE.sanity -= 20;
            STATE.decodedLore.push(id);
            playSound('click');
            logMessage("ARQUIVO DECODIFICADO. A VERDADE D√ìI.");
        } else {
            playSound('shock');
            logMessage("SANIDADE INSUFICIENTE.");
        }
    }

    // --- MINIGAME LOGIC ---
    function winMinigame() {
        STATE.sanity = Math.min(100, STATE.sanity + 15);
        playSound('trophy');
        STATE.quiz.resultMsg = "VIT√ìRIA! SANIDADE +15";
        STATE.screenView = 'RESULT';
        setTimeout(() => { STATE.screenView = 'GAMES_MENU'; }, 2000);
    }

    function initSnake() {
        STATE.minigame.snake = { snake: [{x:10, y:10}], dir: {x:1, y:0}, food: {x:15, y:15}, score: 0, speed: 10, tick: 0 };
        STATE.screenView = 'GAME_SNAKE';
    }
    function updateAndDrawSnake(ctx) {
        const s = STATE.minigame.snake;
        ctx.fillText(`SCORE: ${s.score}/5`, 20, 30);
        ctx.fillStyle = CRT_COLOR;
        osButtons.push({ action: 'BACK_GAME', ...drawButton(ctx, 380, 450, 100, 40, "SAIR") });

        s.tick++;
        if (s.tick > s.speed) {
            s.tick = 0;
            const head = { x: s.snake[0].x + s.dir.x, y: s.snake[0].y + s.dir.y };
            if (head.x < 0 || head.x >= 25 || head.y < 0 || head.y >= 25) { playSound('shock'); initSnake(); return; }
            for(let p of s.snake) if(head.x===p.x && head.y===p.y) { playSound('shock'); initSnake(); return; }
            s.snake.unshift(head);
            if (head.x === s.food.x && head.y === s.food.y) {
                s.score++;
                s.food = { x: Math.floor(Math.random()*25), y: Math.floor(Math.random()*25) };
                playSound('click');
                if (s.score >= 5) winMinigame();
            } else {
                s.snake.pop();
            }
        }
        const size = 18;
        ctx.fillStyle = CRT_COLOR;
        s.snake.forEach(p => ctx.fillRect(20 + p.x * size, 50 + p.y * size, size-2, size-2));
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(20 + s.food.x * size, 50 + s.food.y * size, size-2, size-2);
    }

    function initMemory() {
        const icons = ['A', 'B', 'C', 'D', 'E', 'F'];
        let cards = [...icons, ...icons];
        cards = cards.sort(() => Math.random() - 0.5).map((val, i) => ({ id: i, val, flipped: false, matched: false }));
        STATE.minigame.memory = { cards, flipped: [], matches: 0, locked: false };
        STATE.screenView = 'GAME_MEMORY';
    }
    function drawMemory(ctx) {
        ctx.fillText(`PARES: ${STATE.minigame.memory.matches}/6`, 20, 30);
        osButtons.push({ action: 'BACK_GAME', ...drawButton(ctx, 380, 450, 100, 40, "SAIR") });
        const cols = 4; const size = 80; const gap = 10;
        STATE.minigame.memory.cards.forEach((card, i) => {
            const c = i % cols; const r = Math.floor(i / cols);
            const x = 50 + c * (size + gap); const y = 60 + r * (size + gap);
            osButtons.push({ action: `MEM_${i}`, x, y, w: size, h: size });
            ctx.strokeStyle = CRT_COLOR; ctx.strokeRect(x, y, size, size);
            if (card.flipped || card.matched) {
                ctx.fillStyle = card.matched ? '#00ff00' : CRT_COLOR;
                ctx.font = '40px monospace';
                ctx.fillText(card.val, x + 25, y + 55);
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(x+5, y+5, size-10, size-10);
            }
        });
    }
    function handleMemoryClick(idx) {
        const m = STATE.minigame.memory;
        if (m.locked || m.cards[idx].flipped || m.cards[idx].matched) return;
        m.cards[idx].flipped = true;
        m.flipped.push(idx);
        playSound('click');
        if (m.flipped.length === 2) {
            m.locked = true;
            const c1 = m.cards[m.flipped[0]];
            const c2 = m.cards[m.flipped[1]];
            if (c1.val === c2.val) {
                c1.matched = true; c2.matched = true;
                m.flipped = []; m.locked = false; m.matches++;
                playSound('click');
                if (m.matches === 6) winMinigame();
            } else {
                setTimeout(() => {
                    c1.flipped = false; c2.flipped = false;
                    m.flipped = []; m.locked = false;
                    playSound('shock');
                }, 800);
            }
        }
    }

    function initPacman(isRevival = false) {
        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,2,2,2,2,1,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,2,1],
            [1,2,1,2,2,2,2,2,2,2,2,1,2,2,1],
            [1,2,1,2,1,1,1,1,1,1,2,1,2,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,0,1,1,2,1,1,2,1],
            [1,2,2,2,2,1,0,0,0,1,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,1,1,2,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,2,1,1,1,2,1],
            [1,2,2,2,1,2,2,1,2,2,1,2,2,2,1],
            [1,1,1,2,1,1,2,1,2,1,1,2,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        let totalDots = 0;
        map.forEach(row => row.forEach(cell => { if(cell===2) totalDots++; }));
        STATE.minigame.isRevival = isRevival;
        STATE.minigame.pacman = { player: {x:1, y:1}, ghost: {x:7, y:7, tick: 0, speed: 16}, score: 0, totalDots, map, width: 15, height: 15 };
        STATE.screenView = 'GAME_PACMAN';
    }
    
    function checkPacmanWin() { return STATE.minigame.pacman.score >= STATE.minigame.pacman.totalDots; }
    
    function updateAndDrawPacman(ctx) {
        const p = STATE.minigame.pacman;
        if (STATE.minigame.isRevival) {
            ctx.fillStyle = '#ff0000';
            ctx.font = '20px monospace';
            ctx.fillText("PROTOCOLO DE EMERG√äNCIA", 120, 30);
        } else {
            ctx.fillText(`DOTS: ${p.score}/${p.totalDots}`, 20, 30);
            osButtons.push({ action: 'BACK_GAME', ...drawButton(ctx, 380, 450, 100, 40, "SAIR") });
        }
        const size = 25;
        const offsetX = 60; const offsetY = 50;
        p.ghost.tick++;
        if (p.ghost.tick > p.ghost.speed) {
            p.ghost.tick = 0;
            const startNode = {x: p.ghost.x, y: p.ghost.y};
            const targetNode = {x: p.player.x, y: p.player.y};
            let queue = [ [startNode] ];
            let visited = new Set();
            visited.add(`${startNode.x},${startNode.y}`);
            let nextMove = null;
            let iterations = 0;
            while (queue.length > 0 && iterations < 300) {
                iterations++;
                let path = queue.shift();
                let current = path[path.length - 1];
                if (current.x === targetNode.x && current.y === targetNode.y) {
                    if (path.length > 1) { nextMove = path[1]; }
                    break;
                }
                const neighbors = [{x: current.x, y: current.y - 1}, {x: current.x, y: current.y + 1}, {x: current.x - 1, y: current.y}, {x: current.x + 1, y: current.y}];
                for (let neighbor of neighbors) {
                    if (neighbor.x >= 0 && neighbor.x < p.width && neighbor.y >= 0 && neighbor.y < p.height && p.map[neighbor.y][neighbor.x] !== 1) {
                        const key = `${neighbor.x},${neighbor.y}`;
                        if (!visited.has(key)) { visited.add(key); let newPath = [...path, neighbor]; queue.push(newPath); }
                    }
                }
            }
            if (nextMove) { p.ghost.x = nextMove.x; p.ghost.y = nextMove.y; }
            if (p.ghost.x === p.player.x && p.ghost.y === p.player.y) {
                playSound('shock');
                if (STATE.minigame.isRevival) { triggerGameOver(STATE.revivalReason); } else { initPacman(); }
                return;
            }
        }
        for(let y=0; y<p.height; y++) {
            for(let x=0; x<p.width; x++) {
                const type = p.map[y][x];
                const px = offsetX + x * size;
                const py = offsetY + y * size;
                if (type === 1) { ctx.fillStyle = '#3333cc'; ctx.fillRect(px, py, size, size); } else if (type === 2) { ctx.fillStyle = '#ffcc00'; ctx.fillRect(px + 10, py + 10, 5, 5); }
            }
        }
        ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(offsetX + p.ghost.x * size + size/2, offsetY + p.ghost.y * size + size/2, size/2 - 2, 0, 2 * Math.PI); ctx.fill();
        ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(offsetX + p.player.x * size + size/2, offsetY + p.player.y * size + size/2, size/2 - 2, 0.2 * Math.PI, 1.8 * Math.PI); ctx.lineTo(offsetX + p.player.x * size + size/2, offsetY + p.player.y * size + size/2); ctx.fill();
    }

    function startExpedition(loc) {
        STATE.currentLocation = loc; playSound('travel');
        const p = QUIZ_DATA[loc]; const q = p[Math.floor(Math.random()*p.length)];
        STATE.quiz = { question: q.q, options: q.opt, answer: q.ans, rewardType: q.type, rewardAmount: q.val, failAmount: q.fail };
        STATE.screenView = 'LOCATION_QUIZ';
    }

    function handleQuizAnswer(idx) {
        const ok = idx === STATE.quiz.answer;
        if (ok) {
            if (STATE.quiz.rewardType === 'survivor') {
                STATE.dailySurvivorsLetIn++;
                STATE.stats.humansSaved++;
                unlockTrophy('SAVIOR');
                STATE.quiz.resultMsg = "SOBREVIVENTE RESGATADO!";
            } else if (STATE.quiz.rewardType === 'lore') {
                const remaining = LORE_DATABASE.filter(l => !STATE.unlockedLore.includes(l.id));
                if (remaining.length > 0) {
                    const log = remaining[Math.floor(Math.random() * remaining.length)];
                    STATE.unlockedLore.push(log.id);
                    STATE.quiz.resultMsg = "DADOS CRIPTOGRAFADOS!";
                } else {
                    STATE.quiz.resultMsg = "DADOS J√Å OBTIDOS.";
                }
            } else {
                STATE[STATE.quiz.rewardType] = Math.min(100, STATE[STATE.quiz.rewardType] + STATE.quiz.rewardAmount);
                STATE.quiz.resultMsg = "SUCESSO!";
            }
            if (Math.random() < 0.3 && STATE.quiz.rewardType !== 'lore') {
                const remaining = LORE_DATABASE.filter(l => !STATE.unlockedLore.includes(l.id));
                if (remaining.length > 0) {
                    const log = remaining[Math.floor(Math.random() * remaining.length)];
                    STATE.unlockedLore.push(log.id);
                    logMessage(`DADOS ENCONTRADOS: ${log.title}`);
                }
            }
            playSound('click');
        } else {
            STATE.energy = Math.max(0, STATE.energy - 10); STATE.sanity = Math.max(0, STATE.sanity + STATE.quiz.failAmount);
            playSound('shock'); STATE.quiz.resultMsg = "FALHA.";
        }
        STATE.screenView = 'RESULT'; setTimeout(() => { STATE.screenView = 'DESKTOP'; STATE.currentLocation = 'BUNKER'; }, 2000);
    }

    function checkState() {
        if (STATE.day > STATE.maxDays) { document.body.innerHTML = `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;background:black;color:#ffcc00;font-family:monospace;"><h1>DIA 8: RESGATE CHEGOU</h1><p>Voc√™ sobreviveu.</p><button onclick="location.reload()">REINICIAR</button></div>`; STATE.playing = false; }
        else if (STATE.energy <= 0) triggerGameOver("Sem Energia.");
        else if (STATE.sanity <= 0) triggerGameOver("Loucura Total.");
        else if (STATE.doorHealth <= 0) triggerGameOver("Porta Destru√≠da.");
        else if (STATE.familyMood <= 0) triggerGameOver("Motim Familiar.");
        else if (STATE.familyHealth <= 0) triggerGameOver("Fam√≠lia Pereceu."); 
    }

    function triggerGameOver(r) {
        if (!STATE.revivalUsed) {
            STATE.revivalUsed = true;
            STATE.revivalReason = r;
            playSound('jumpscare');
            STATE.lookingAtPeephole = false;
            document.exitPointerLock();
            initPacman(true);
            logMessage("ERRO CR√çTICO! INICIANDO PROTOCOLO DE EMERG√äNCIA...");
            setTimeout(() => logMessage("VEN√áA O JOGO PARA SOBREVIVER"), 1500);
            return;
        }
        STATE.gameOver = true; 
        playSound('jumpscare'); 
        document.getElementById('vhs-overlay').style.background = 'red';
        setTimeout(() => document.body.innerHTML = `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;background:black;color:red;font-family:monospace;text-align:center;"><h1>FIM DE JOGO</h1><p>${r}</p><button onclick="location.reload()">REINICIAR</button></div>`, 2000);
    }

    function revivePlayer() {
        STATE.sanity = Math.max(STATE.sanity, 50);
        STATE.energy = Math.max(STATE.energy, 50);
        STATE.doorHealth = Math.max(STATE.doorHealth, 50);
        STATE.familyMood = Math.max(STATE.familyMood, 50);
        STATE.familyHealth = Math.max(STATE.familyHealth, 50);
        STATE.doorKnocking = false; 
        STATE.minigame.isRevival = false;
        STATE.screenView = 'DESKTOP';
        playSound('trophy');
        logMessage("SISTEMA RESTAURADO. SEGUNDA CHANCE ATIVADA.");
        document.body.requestPointerLock();
    }

    function handleMonitorClick(uv) {
        const x = uv.x * CANVAS_W, y = (1 - uv.y) * CANVAS_H; 
        let clickedUI = false;
        for (let btn of osButtons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                clickedUI = true;
                playSound('click');
                if (btn.action === 'GO_MAP') STATE.screenView = 'MAP';
                else if (btn.action === 'GO_FAMILY') STATE.screenView = 'FAMILY';
                else if (btn.action === 'GO_REPAIR') STATE.screenView = 'REPAIR';
                else if (btn.action === 'GO_TROPHIES') STATE.screenView = 'TROPHIES';
                else if (btn.action === 'GO_GAMES') STATE.screenView = 'GAMES_MENU';
                else if (btn.action === 'GO_RADIO') initRadio(); 
                else if (btn.action === 'GO_ARCHIVES') STATE.screenView = 'ARCHIVES';
                else if (btn.action === 'GO_DECODER') STATE.screenView = 'DECODER'; 
                else if (btn.action === 'START_SNAKE') initSnake();
                else if (btn.action === 'START_MEMORY') initMemory();
                else if (btn.action === 'START_PACMAN') initPacman();
                else if (btn.action === 'BACK_GAME') STATE.screenView = 'GAMES_MENU';
                else if (btn.action === 'MAIL') STATE.screenView = 'MAIL';
                else if (btn.action === 'BACK') STATE.screenView = 'DESKTOP';
                else if (btn.action === 'FAM_FEED' && STATE.energy >= 20) { STATE.energy -= 20; STATE.familyMood = Math.min(100, STATE.familyMood + 30); }
                else if (btn.action === 'FAM_TALK' && STATE.energy >= 10) { STATE.energy -= 10; STATE.sanity = Math.min(100, STATE.sanity + 10); }
                else if (btn.action === 'FAM_MEDIC' && STATE.energy >= 30) { STATE.energy -= 30; STATE.familyHealth = Math.min(100, STATE.familyHealth + 30); STATE.stats.familyHeals++; }
                else if (btn.action === 'FAM_PLAY' && STATE.energy >= 15) { STATE.energy -= 15; STATE.familyMood = Math.min(100, STATE.familyMood + 20); }
                else if (btn.action === 'REP_DOOR' && STATE.energy >= 30) { STATE.energy -= 30; STATE.doorHealth = Math.min(100, STATE.doorHealth + 40); unlockTrophy('MECHANIC'); }
                else if (btn.action === 'GO_MARKET') startExpedition('MARKET');
                else if (btn.action === 'GO_PHARMA') startExpedition('PHARMACY');
                else if (btn.action === 'GO_STREET') startExpedition('STREETS');
                else if (btn.action === 'RADIO_LURE' && STATE.energy >= 40) { STATE.energy -= 40; triggerKnockEvent('good'); logMessage("Sinal enviado. Algu√©m se aproxima."); }
                else if (btn.action.startsWith('ANS_')) handleQuizAnswer(parseInt(btn.action.split('_')[1]));
                else if (btn.action.startsWith('MEM_')) handleMemoryClick(parseInt(btn.action.split('_')[1]));
                else if (btn.action.startsWith('DECRYPT_')) handleDecrypt(parseInt(btn.action.split('_')[1]));
            }
        }
    }

    function triggerKnockEvent(forcedType = null) {
        if (STATE.doorKnocking || STATE.currentLocation !== 'BUNKER' || STATE.isNarrativeMode) return;
        STATE.doorKnocking = true;
        let pool = VISITOR_TYPES;
        if (forcedType === 'good') pool = VISITOR_TYPES.filter(v => v.type === 'good');
        if (forcedType === 'bad') pool = VISITOR_TYPES.filter(v => v.type === 'bad');
        STATE.visitor = pool[Math.floor(Math.random() * pool.length)];
        STATE.interrogated = false; 
        playSound('knock', {x: 3, y: 1, z: 0});
        updateHUD();
        const b = setInterval(() => { if (!STATE.doorKnocking) { clearInterval(b); pointLightEmergency.intensity = 0; return; } pointLightEmergency.intensity = pointLightEmergency.intensity > 0 ? 0 : 3; }, 600);
        logMessage(`ALERTA NA PORTA.`);
    }

    function resolveDoor(open) {
        STATE.doorKnocking = false; pointLightEmergency.intensity = 0; exitPeepholeMode();
        if (open) {
            if (STATE.visitor.type === 'good') {
                if (STATE.visitor.reward.energy) STATE.energy += STATE.visitor.reward.energy;
                if (STATE.visitor.reward.sanity) STATE.sanity += STATE.visitor.reward.sanity;
                if (STATE.visitor.reward.door) STATE.doorHealth += STATE.visitor.reward.door;
                STATE.dailySurvivorsLetIn++;
                STATE.stats.humansSaved++; if (STATE.stats.humansSaved >= 3) unlockTrophy('SAVIOR');
                playSound('click'); logMessage("Acesso permitido.");
            } else {
                STATE.doorHealth -= STATE.visitor.damage.door; STATE.sanity -= STATE.visitor.damage.sanity;
                playSound('shock'); logMessage("ERRO! Intruso!");
            }
        } else {
            playSound('shock', {x: 3, y: 1, z: 0}); unlockTrophy('FIRST_BLOOD');
            if (STATE.visitor.type === 'good') { STATE.sanity -= 20; logMessage("Inocente eletrocutado."); }
            else { STATE.sanity += 10; STATE.stats.monstersKilled++; if (STATE.stats.monstersKilled >= 3) unlockTrophy('SLAYER'); logMessage("Amea√ßa eliminada."); }
        }
        STATE.energy = Math.min(100, STATE.energy); STATE.sanity = Math.min(100, STATE.sanity);
        STATE.doorHealth = Math.min(100, STATE.doorHealth);
        checkState();
    }

    function enterPeepholeMode() {
        if (!STATE.doorKnocking) { logMessage("Ningu√©m."); return; }
        STATE.lookingAtPeephole = true; document.exitPointerLock();
        document.getElementById('peephole-ui').style.display = 'block'; document.getElementById('dialogue-box').style.display = 'none';
        document.getElementById('visitor-visual').innerText = STATE.visitor.visual;
        camera.position.set(2.5, 1.6, 0); camera.lookAt(4, 1.6, 0);
    }
    
    function exitPeepholeMode() {
        STATE.lookingAtPeephole = false; document.getElementById('peephole-ui').style.display = 'none';
        document.body.requestPointerLock(); 
        camPitch = 0; camYaw = 0; targetPitch = 0; targetYaw = 0;
        camera.position.set(0, 1.2, 2); camera.lookAt(0, 1.2, 0);
    }
    
    function interrogateVisitor() {
        if (STATE.interrogated) return; STATE.interrogated = true; generateVisitorDialogue(STATE.visitor);
    }
    
    function logMessage(msg) {
        const el = document.getElementById('message-log'); el.innerText = `> ${msg}`; el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 3000);
    }

    function init3D() {
        const c = document.getElementById('game-container');
        scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050505, 0.15);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100); camera.position.set(0, 1.2, 2);
        renderer = new THREE.WebGLRenderer({ antialias: false }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; c.appendChild(renderer.domElement);
        const w = createNoiseMaterial(0x444444); const r = new THREE.Mesh(new THREE.BoxGeometry(6,4,6), w); r.material.side = THREE.BackSide; scene.add(r);
        const d = new THREE.Mesh(new THREE.BoxGeometry(2.5,0.1,1.5), createNoiseMaterial(0x333333)); d.position.set(0,0.8,0); scene.add(d);
        initMonitorOS(); monitorMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.6,0.6), new THREE.MeshBasicMaterial({map:monitorTexture, side:THREE.DoubleSide})); monitorMesh.position.set(0,1.2,0.31); monitorMesh.name="MONITOR"; scene.add(monitorMesh);
        const dr = new THREE.Mesh(new THREE.BoxGeometry(0.1,2.2,1.2), new THREE.MeshStandardMaterial({color:0x2a2a2a})); dr.position.set(2.95,1.1,0); dr.name="DOOR"; scene.add(dr);
        const pp = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,0.15,16), new THREE.MeshBasicMaterial({color:0x000})); pp.rotation.z=Math.PI/2; pp.position.set(2.90,1.6,0); pp.name="PEEPHOLE"; scene.add(pp);
        scene.add(new THREE.AmbientLight(0x111111));
        pointLightPC = new THREE.PointLight(0xffcc00, 1, 4); pointLightPC.position.set(0,1.2,0.5); scene.add(pointLightPC);
        pointLightEmergency = new THREE.PointLight(0xff0000, 0, 15); pointLightEmergency.position.set(2.5,2.8,0); scene.add(pointLightEmergency);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('click', () => {
            if(!STATE.playing || STATE.gameOver || STATE.lookingAtPeephole) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const h = raycaster.intersectObjects(scene.children);
            if(h.length){ if(h[0].object.name==="MONITOR") handleMonitorClick(h[0].uv); else if(h[0].object.name==="PEEPHOLE" || h[0].object.name==="DOOR") enterPeepholeMode(); }
        });
    }

    function createNoiseMaterial(c) {
        const cv = document.createElement('canvas'); cv.width=64; cv.height=64;
        const x = cv.getContext('2d'); x.fillStyle = '#'+c.toString(16); x.fillRect(0,0,64,64);
        for(let i=0;i<500;i++){ x.fillStyle=`rgba(0,0,0,${Math.random()*0.2})`; x.fillRect(Math.random()*64,Math.random()*64,2,2); }
        return new THREE.MeshStandardMaterial({map:new THREE.CanvasTexture(cv), roughness:0.9});
    }

    function animate() {
        requestAnimationFrame(animate); if(!STATE.playing || STATE.gameOver) return;
        const dt = clock.getDelta();
        updateTimer(dt);
        updateCameraSmooth();
        updateEnvironment3D(); updateHUD(); drawOS();
        renderer.render(scene, camera);
    }

    document.getElementById('overlay').addEventListener('click', () => {
        document.getElementById('overlay').style.display = 'none';
        document.body.requestPointerLock();
        initAudio(); init3D(); playSound('hum');
        STATE.playing = true; clock.start(); animate();
    });
</script>
</body>
</html>